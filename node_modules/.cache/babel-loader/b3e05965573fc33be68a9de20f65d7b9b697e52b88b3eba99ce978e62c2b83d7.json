{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { createClientPipeline } from \"./pipeline.js\";\nimport { flattenResponse } from \"./utils.js\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache.js\";\nimport { getOperationRequestInfo } from \"./operationHelpers.js\";\nimport { getRequestUrl } from \"./urlHelpers.js\";\nimport { getStreamingResponseStatusCodes } from \"./interfaceHelpers.js\";\nimport { logger } from \"./log.js\";\n/**\n * Initializes a new instance of the ServiceClient.\n */\nexport class ServiceClient {\n  /**\n   * The ServiceClient constructor\n   * @param credential - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(options = {}) {\n    var _a, _b;\n    this._requestContentType = options.requestContentType;\n    this._endpoint = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri;\n    if (options.baseUri) {\n      logger.warning(\"The baseUri option for SDK Clients has been deprecated, please use endpoint instead.\");\n    }\n    this._allowInsecureConnection = options.allowInsecureConnection;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this.pipeline = options.pipeline || createDefaultPipeline(options);\n    if ((_b = options.additionalPolicies) === null || _b === void 0 ? void 0 : _b.length) {\n      for (const {\n        policy,\n        position\n      } of options.additionalPolicies) {\n        // Sign happens after Retry and is commonly needed to occur\n        // before policies that intercept post-retry.\n        const afterPhase = position === \"perRetry\" ? \"Sign\" : undefined;\n        this.pipeline.addPolicy(policy, {\n          afterPhase\n        });\n      }\n    }\n  }\n  /**\n   * Send the provided httpRequest.\n   */\n  async sendRequest(request) {\n    return this.pipeline.sendRequest(this._httpClient, request);\n  }\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @typeParam T - The typed result of the request, based on the OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   */\n  async sendOperationRequest(operationArguments, operationSpec) {\n    const endpoint = operationSpec.baseUrl || this._endpoint;\n    if (!endpoint) {\n      throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.\");\n    }\n    // Templatized URLs sometimes reference properties on the ServiceClient child class,\n    // so we have to pass `this` below in order to search these properties if they're\n    // not part of OperationArguments\n    const url = getRequestUrl(endpoint, operationSpec, operationArguments, this);\n    const request = createPipelineRequest({\n      url\n    });\n    request.method = operationSpec.httpMethod;\n    const operationInfo = getOperationRequestInfo(request);\n    operationInfo.operationSpec = operationSpec;\n    operationInfo.operationArguments = operationArguments;\n    const contentType = operationSpec.contentType || this._requestContentType;\n    if (contentType && operationSpec.requestBody) {\n      request.headers.set(\"Content-Type\", contentType);\n    }\n    const options = operationArguments.options;\n    if (options) {\n      const requestOptions = options.requestOptions;\n      if (requestOptions) {\n        if (requestOptions.timeout) {\n          request.timeout = requestOptions.timeout;\n        }\n        if (requestOptions.onUploadProgress) {\n          request.onUploadProgress = requestOptions.onUploadProgress;\n        }\n        if (requestOptions.onDownloadProgress) {\n          request.onDownloadProgress = requestOptions.onDownloadProgress;\n        }\n        if (requestOptions.shouldDeserialize !== undefined) {\n          operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;\n        }\n        if (requestOptions.allowInsecureConnection) {\n          request.allowInsecureConnection = true;\n        }\n      }\n      if (options.abortSignal) {\n        request.abortSignal = options.abortSignal;\n      }\n      if (options.tracingOptions) {\n        request.tracingOptions = options.tracingOptions;\n      }\n    }\n    if (this._allowInsecureConnection) {\n      request.allowInsecureConnection = true;\n    }\n    if (request.streamResponseStatusCodes === undefined) {\n      request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);\n    }\n    try {\n      const rawResponse = await this.sendRequest(request);\n      const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);\n      if (options === null || options === void 0 ? void 0 : options.onResponse) {\n        options.onResponse(rawResponse, flatResponse);\n      }\n      return flatResponse;\n    } catch (error) {\n      if (typeof error === \"object\" && (error === null || error === void 0 ? void 0 : error.response)) {\n        const rawResponse = error.response;\n        const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses[\"default\"]);\n        error.details = flatResponse;\n        if (options === null || options === void 0 ? void 0 : options.onResponse) {\n          options.onResponse(rawResponse, flatResponse, error);\n        }\n      }\n      throw error;\n    }\n  }\n}\nfunction createDefaultPipeline(options) {\n  const credentialScopes = getCredentialScopes(options);\n  const credentialOptions = options.credential && credentialScopes ? {\n    credentialScopes,\n    credential: options.credential\n  } : undefined;\n  return createClientPipeline(Object.assign(Object.assign({}, options), {\n    credentialOptions\n  }));\n}\nfunction getCredentialScopes(options) {\n  if (options.credentialScopes) {\n    return options.credentialScopes;\n  }\n  if (options.endpoint) {\n    return `${options.endpoint}/.default`;\n  }\n  if (options.baseUri) {\n    return `${options.baseUri}/.default`;\n  }\n  if (options.credential && !options.credentialScopes) {\n    throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);\n  }\n  return undefined;\n}","map":{"version":3,"names":["createPipelineRequest","createClientPipeline","flattenResponse","getCachedDefaultHttpClient","getOperationRequestInfo","getRequestUrl","getStreamingResponseStatusCodes","logger","ServiceClient","constructor","options","_requestContentType","requestContentType","_endpoint","_a","endpoint","baseUri","warning","_allowInsecureConnection","allowInsecureConnection","_httpClient","httpClient","pipeline","createDefaultPipeline","_b","additionalPolicies","length","policy","position","afterPhase","undefined","addPolicy","sendRequest","request","sendOperationRequest","operationArguments","operationSpec","baseUrl","Error","url","method","httpMethod","operationInfo","contentType","requestBody","headers","set","requestOptions","timeout","onUploadProgress","onDownloadProgress","shouldDeserialize","abortSignal","tracingOptions","streamResponseStatusCodes","rawResponse","flatResponse","responses","status","onResponse","error","response","statusCode","details","credentialScopes","getCredentialScopes","credentialOptions","credential","Object","assign"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\@azure\\core-client\\src\\serviceClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  CommonClientOptions,\n  OperationArguments,\n  OperationRequest,\n  OperationSpec,\n} from \"./interfaces.js\";\nimport {\n  HttpClient,\n  Pipeline,\n  PipelineRequest,\n  PipelineResponse,\n  createPipelineRequest,\n} from \"@azure/core-rest-pipeline\";\nimport { TokenCredential } from \"@azure/core-auth\";\nimport { createClientPipeline } from \"./pipeline.js\";\nimport { flattenResponse } from \"./utils.js\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache.js\";\nimport { getOperationRequestInfo } from \"./operationHelpers.js\";\nimport { getRequestUrl } from \"./urlHelpers.js\";\nimport { getStreamingResponseStatusCodes } from \"./interfaceHelpers.js\";\nimport { logger } from \"./log.js\";\n\n/**\n * Options to be provided while creating the client.\n */\nexport interface ServiceClientOptions extends CommonClientOptions {\n  /**\n   * If specified, this is the base URI that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   * @deprecated This property is deprecated and will be removed soon, please use endpoint instead\n   */\n  baseUri?: string;\n  /**\n   * If specified, this is the endpoint that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   * to encourage customer to use endpoint, we mark the baseUri as deprecated.\n   */\n  endpoint?: string;\n  /**\n   * If specified, will be used to build the BearerTokenAuthenticationPolicy.\n   */\n  credentialScopes?: string | string[];\n  /**\n   * The default request content type for the service.\n   * Used if no requestContentType is present on an OperationSpec.\n   */\n  requestContentType?: string;\n  /**\n   * Credential used to authenticate the request.\n   */\n  credential?: TokenCredential;\n  /**\n   * A customized pipeline to use, otherwise a default one will be created.\n   */\n  pipeline?: Pipeline;\n}\n\n/**\n * Initializes a new instance of the ServiceClient.\n */\nexport class ServiceClient {\n  /**\n   * If specified, this is the base URI that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   */\n  private readonly _endpoint?: string;\n\n  /**\n   * The default request content type for the service.\n   * Used if no requestContentType is present on an OperationSpec.\n   */\n  private readonly _requestContentType?: string;\n\n  /**\n   * Set to true if the request is sent over HTTP instead of HTTPS\n   */\n  private readonly _allowInsecureConnection?: boolean;\n\n  /**\n   * The HTTP client that will be used to send requests.\n   */\n  private readonly _httpClient: HttpClient;\n\n  /**\n   * The pipeline used by this client to make requests\n   */\n  public readonly pipeline: Pipeline;\n\n  /**\n   * The ServiceClient constructor\n   * @param credential - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(options: ServiceClientOptions = {}) {\n    this._requestContentType = options.requestContentType;\n    this._endpoint = options.endpoint ?? options.baseUri;\n    if (options.baseUri) {\n      logger.warning(\n        \"The baseUri option for SDK Clients has been deprecated, please use endpoint instead.\",\n      );\n    }\n    this._allowInsecureConnection = options.allowInsecureConnection;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n\n    this.pipeline = options.pipeline || createDefaultPipeline(options);\n    if (options.additionalPolicies?.length) {\n      for (const { policy, position } of options.additionalPolicies) {\n        // Sign happens after Retry and is commonly needed to occur\n        // before policies that intercept post-retry.\n        const afterPhase = position === \"perRetry\" ? \"Sign\" : undefined;\n        this.pipeline.addPolicy(policy, {\n          afterPhase,\n        });\n      }\n    }\n  }\n\n  /**\n   * Send the provided httpRequest.\n   */\n  async sendRequest(request: PipelineRequest): Promise<PipelineResponse> {\n    return this.pipeline.sendRequest(this._httpClient, request);\n  }\n\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @typeParam T - The typed result of the request, based on the OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   */\n  async sendOperationRequest<T>(\n    operationArguments: OperationArguments,\n    operationSpec: OperationSpec,\n  ): Promise<T> {\n    const endpoint: string | undefined = operationSpec.baseUrl || this._endpoint;\n    if (!endpoint) {\n      throw new Error(\n        \"If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.\",\n      );\n    }\n\n    // Templatized URLs sometimes reference properties on the ServiceClient child class,\n    // so we have to pass `this` below in order to search these properties if they're\n    // not part of OperationArguments\n    const url = getRequestUrl(endpoint, operationSpec, operationArguments, this);\n\n    const request: OperationRequest = createPipelineRequest({\n      url,\n    });\n    request.method = operationSpec.httpMethod;\n    const operationInfo = getOperationRequestInfo(request);\n    operationInfo.operationSpec = operationSpec;\n    operationInfo.operationArguments = operationArguments;\n\n    const contentType = operationSpec.contentType || this._requestContentType;\n    if (contentType && operationSpec.requestBody) {\n      request.headers.set(\"Content-Type\", contentType);\n    }\n\n    const options = operationArguments.options;\n    if (options) {\n      const requestOptions = options.requestOptions;\n\n      if (requestOptions) {\n        if (requestOptions.timeout) {\n          request.timeout = requestOptions.timeout;\n        }\n\n        if (requestOptions.onUploadProgress) {\n          request.onUploadProgress = requestOptions.onUploadProgress;\n        }\n\n        if (requestOptions.onDownloadProgress) {\n          request.onDownloadProgress = requestOptions.onDownloadProgress;\n        }\n\n        if (requestOptions.shouldDeserialize !== undefined) {\n          operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;\n        }\n\n        if (requestOptions.allowInsecureConnection) {\n          request.allowInsecureConnection = true;\n        }\n      }\n\n      if (options.abortSignal) {\n        request.abortSignal = options.abortSignal;\n      }\n\n      if (options.tracingOptions) {\n        request.tracingOptions = options.tracingOptions;\n      }\n    }\n\n    if (this._allowInsecureConnection) {\n      request.allowInsecureConnection = true;\n    }\n\n    if (request.streamResponseStatusCodes === undefined) {\n      request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);\n    }\n\n    try {\n      const rawResponse = await this.sendRequest(request);\n      const flatResponse = flattenResponse(\n        rawResponse,\n        operationSpec.responses[rawResponse.status],\n      ) as T;\n      if (options?.onResponse) {\n        options.onResponse(rawResponse, flatResponse);\n      }\n      return flatResponse;\n    } catch (error: any) {\n      if (typeof error === \"object\" && error?.response) {\n        const rawResponse = error.response;\n        const flatResponse = flattenResponse(\n          rawResponse,\n          operationSpec.responses[error.statusCode] || operationSpec.responses[\"default\"],\n        );\n        error.details = flatResponse;\n        if (options?.onResponse) {\n          options.onResponse(rawResponse, flatResponse, error);\n        }\n      }\n      throw error;\n    }\n  }\n}\n\nfunction createDefaultPipeline(options: ServiceClientOptions): Pipeline {\n  const credentialScopes = getCredentialScopes(options);\n  const credentialOptions =\n    options.credential && credentialScopes\n      ? { credentialScopes, credential: options.credential }\n      : undefined;\n\n  return createClientPipeline({\n    ...options,\n    credentialOptions,\n  });\n}\n\nfunction getCredentialScopes(options: ServiceClientOptions): string | string[] | undefined {\n  if (options.credentialScopes) {\n    return options.credentialScopes;\n  }\n\n  if (options.endpoint) {\n    return `${options.endpoint}/.default`;\n  }\n\n  if (options.baseUri) {\n    return `${options.baseUri}/.default`;\n  }\n\n  if (options.credential && !options.credentialScopes) {\n    throw new Error(\n      `When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`,\n    );\n  }\n\n  return undefined;\n}\n"],"mappings":"AAAA;AACA;AAQA,SAKEA,qBAAqB,QAChB,2BAA2B;AAElC,SAASC,oBAAoB,QAAQ,eAAe;AACpD,SAASC,eAAe,QAAQ,YAAY;AAC5C,SAASC,0BAA0B,QAAQ,sBAAsB;AACjE,SAASC,uBAAuB,QAAQ,uBAAuB;AAC/D,SAASC,aAAa,QAAQ,iBAAiB;AAC/C,SAASC,+BAA+B,QAAQ,uBAAuB;AACvE,SAASC,MAAM,QAAQ,UAAU;AAqCjC;;;AAGA,OAAM,MAAOC,aAAa;EA4BxB;;;;;EAKAC,YAAYC,OAAA,GAAgC,EAAE;;IAC5C,IAAI,CAACC,mBAAmB,GAAGD,OAAO,CAACE,kBAAkB;IACrD,IAAI,CAACC,SAAS,GAAG,CAAAC,EAAA,GAAAJ,OAAO,CAACK,QAAQ,cAAAD,EAAA,cAAAA,EAAA,GAAIJ,OAAO,CAACM,OAAO;IACpD,IAAIN,OAAO,CAACM,OAAO,EAAE;MACnBT,MAAM,CAACU,OAAO,CACZ,sFAAsF,CACvF;IACH;IACA,IAAI,CAACC,wBAAwB,GAAGR,OAAO,CAACS,uBAAuB;IAC/D,IAAI,CAACC,WAAW,GAAGV,OAAO,CAACW,UAAU,IAAIlB,0BAA0B,EAAE;IAErE,IAAI,CAACmB,QAAQ,GAAGZ,OAAO,CAACY,QAAQ,IAAIC,qBAAqB,CAACb,OAAO,CAAC;IAClE,IAAI,CAAAc,EAAA,GAAAd,OAAO,CAACe,kBAAkB,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,MAAM,EAAE;MACtC,KAAK,MAAM;QAAEC,MAAM;QAAEC;MAAQ,CAAE,IAAIlB,OAAO,CAACe,kBAAkB,EAAE;QAC7D;QACA;QACA,MAAMI,UAAU,GAAGD,QAAQ,KAAK,UAAU,GAAG,MAAM,GAAGE,SAAS;QAC/D,IAAI,CAACR,QAAQ,CAACS,SAAS,CAACJ,MAAM,EAAE;UAC9BE;SACD,CAAC;MACJ;IACF;EACF;EAEA;;;EAGA,MAAMG,WAAWA,CAACC,OAAwB;IACxC,OAAO,IAAI,CAACX,QAAQ,CAACU,WAAW,CAAC,IAAI,CAACZ,WAAW,EAAEa,OAAO,CAAC;EAC7D;EAEA;;;;;;EAMA,MAAMC,oBAAoBA,CACxBC,kBAAsC,EACtCC,aAA4B;IAE5B,MAAMrB,QAAQ,GAAuBqB,aAAa,CAACC,OAAO,IAAI,IAAI,CAACxB,SAAS;IAC5E,IAAI,CAACE,QAAQ,EAAE;MACb,MAAM,IAAIuB,KAAK,CACb,2IAA2I,CAC5I;IACH;IAEA;IACA;IACA;IACA,MAAMC,GAAG,GAAGlC,aAAa,CAACU,QAAQ,EAAEqB,aAAa,EAAED,kBAAkB,EAAE,IAAI,CAAC;IAE5E,MAAMF,OAAO,GAAqBjC,qBAAqB,CAAC;MACtDuC;KACD,CAAC;IACFN,OAAO,CAACO,MAAM,GAAGJ,aAAa,CAACK,UAAU;IACzC,MAAMC,aAAa,GAAGtC,uBAAuB,CAAC6B,OAAO,CAAC;IACtDS,aAAa,CAACN,aAAa,GAAGA,aAAa;IAC3CM,aAAa,CAACP,kBAAkB,GAAGA,kBAAkB;IAErD,MAAMQ,WAAW,GAAGP,aAAa,CAACO,WAAW,IAAI,IAAI,CAAChC,mBAAmB;IACzE,IAAIgC,WAAW,IAAIP,aAAa,CAACQ,WAAW,EAAE;MAC5CX,OAAO,CAACY,OAAO,CAACC,GAAG,CAAC,cAAc,EAAEH,WAAW,CAAC;IAClD;IAEA,MAAMjC,OAAO,GAAGyB,kBAAkB,CAACzB,OAAO;IAC1C,IAAIA,OAAO,EAAE;MACX,MAAMqC,cAAc,GAAGrC,OAAO,CAACqC,cAAc;MAE7C,IAAIA,cAAc,EAAE;QAClB,IAAIA,cAAc,CAACC,OAAO,EAAE;UAC1Bf,OAAO,CAACe,OAAO,GAAGD,cAAc,CAACC,OAAO;QAC1C;QAEA,IAAID,cAAc,CAACE,gBAAgB,EAAE;UACnChB,OAAO,CAACgB,gBAAgB,GAAGF,cAAc,CAACE,gBAAgB;QAC5D;QAEA,IAAIF,cAAc,CAACG,kBAAkB,EAAE;UACrCjB,OAAO,CAACiB,kBAAkB,GAAGH,cAAc,CAACG,kBAAkB;QAChE;QAEA,IAAIH,cAAc,CAACI,iBAAiB,KAAKrB,SAAS,EAAE;UAClDY,aAAa,CAACS,iBAAiB,GAAGJ,cAAc,CAACI,iBAAiB;QACpE;QAEA,IAAIJ,cAAc,CAAC5B,uBAAuB,EAAE;UAC1Cc,OAAO,CAACd,uBAAuB,GAAG,IAAI;QACxC;MACF;MAEA,IAAIT,OAAO,CAAC0C,WAAW,EAAE;QACvBnB,OAAO,CAACmB,WAAW,GAAG1C,OAAO,CAAC0C,WAAW;MAC3C;MAEA,IAAI1C,OAAO,CAAC2C,cAAc,EAAE;QAC1BpB,OAAO,CAACoB,cAAc,GAAG3C,OAAO,CAAC2C,cAAc;MACjD;IACF;IAEA,IAAI,IAAI,CAACnC,wBAAwB,EAAE;MACjCe,OAAO,CAACd,uBAAuB,GAAG,IAAI;IACxC;IAEA,IAAIc,OAAO,CAACqB,yBAAyB,KAAKxB,SAAS,EAAE;MACnDG,OAAO,CAACqB,yBAAyB,GAAGhD,+BAA+B,CAAC8B,aAAa,CAAC;IACpF;IAEA,IAAI;MACF,MAAMmB,WAAW,GAAG,MAAM,IAAI,CAACvB,WAAW,CAACC,OAAO,CAAC;MACnD,MAAMuB,YAAY,GAAGtD,eAAe,CAClCqD,WAAW,EACXnB,aAAa,CAACqB,SAAS,CAACF,WAAW,CAACG,MAAM,CAAC,CACvC;MACN,IAAIhD,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEiD,UAAU,EAAE;QACvBjD,OAAO,CAACiD,UAAU,CAACJ,WAAW,EAAEC,YAAY,CAAC;MAC/C;MACA,OAAOA,YAAY;IACrB,CAAC,CAAC,OAAOI,KAAU,EAAE;MACnB,IAAI,OAAOA,KAAK,KAAK,QAAQ,KAAIA,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEC,QAAQ,GAAE;QAChD,MAAMN,WAAW,GAAGK,KAAK,CAACC,QAAQ;QAClC,MAAML,YAAY,GAAGtD,eAAe,CAClCqD,WAAW,EACXnB,aAAa,CAACqB,SAAS,CAACG,KAAK,CAACE,UAAU,CAAC,IAAI1B,aAAa,CAACqB,SAAS,CAAC,SAAS,CAAC,CAChF;QACDG,KAAK,CAACG,OAAO,GAAGP,YAAY;QAC5B,IAAI9C,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEiD,UAAU,EAAE;UACvBjD,OAAO,CAACiD,UAAU,CAACJ,WAAW,EAAEC,YAAY,EAAEI,KAAK,CAAC;QACtD;MACF;MACA,MAAMA,KAAK;IACb;EACF;;AAGF,SAASrC,qBAAqBA,CAACb,OAA6B;EAC1D,MAAMsD,gBAAgB,GAAGC,mBAAmB,CAACvD,OAAO,CAAC;EACrD,MAAMwD,iBAAiB,GACrBxD,OAAO,CAACyD,UAAU,IAAIH,gBAAgB,GAClC;IAAEA,gBAAgB;IAAEG,UAAU,EAAEzD,OAAO,CAACyD;EAAU,CAAE,GACpDrC,SAAS;EAEf,OAAO7B,oBAAoB,CAAAmE,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACtB3D,OAAO;IACVwD;EAAiB,GACjB;AACJ;AAEA,SAASD,mBAAmBA,CAACvD,OAA6B;EACxD,IAAIA,OAAO,CAACsD,gBAAgB,EAAE;IAC5B,OAAOtD,OAAO,CAACsD,gBAAgB;EACjC;EAEA,IAAItD,OAAO,CAACK,QAAQ,EAAE;IACpB,OAAO,GAAGL,OAAO,CAACK,QAAQ,WAAW;EACvC;EAEA,IAAIL,OAAO,CAACM,OAAO,EAAE;IACnB,OAAO,GAAGN,OAAO,CAACM,OAAO,WAAW;EACtC;EAEA,IAAIN,OAAO,CAACyD,UAAU,IAAI,CAACzD,OAAO,CAACsD,gBAAgB,EAAE;IACnD,MAAM,IAAI1B,KAAK,CACb,2JAA2J,CAC5J;EACH;EAEA,OAAOR,SAAS;AAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}