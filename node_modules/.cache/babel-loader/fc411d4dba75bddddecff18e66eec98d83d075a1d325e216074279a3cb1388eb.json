{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _token = require(\"./token\");\nvar _colmetadataTokenParser = _interopRequireDefault(require(\"./colmetadata-token-parser\"));\nvar _doneTokenParser = require(\"./done-token-parser\");\nvar _envChangeTokenParser = _interopRequireDefault(require(\"./env-change-token-parser\"));\nvar _infoerrorTokenParser = require(\"./infoerror-token-parser\");\nvar _fedauthInfoParser = _interopRequireDefault(require(\"./fedauth-info-parser\"));\nvar _featureExtAckParser = _interopRequireDefault(require(\"./feature-ext-ack-parser\"));\nvar _loginackTokenParser = _interopRequireDefault(require(\"./loginack-token-parser\"));\nvar _orderTokenParser = _interopRequireDefault(require(\"./order-token-parser\"));\nvar _returnstatusTokenParser = _interopRequireDefault(require(\"./returnstatus-token-parser\"));\nvar _returnvalueTokenParser = _interopRequireDefault(require(\"./returnvalue-token-parser\"));\nvar _rowTokenParser = _interopRequireDefault(require(\"./row-token-parser\"));\nvar _nbcrowTokenParser = _interopRequireDefault(require(\"./nbcrow-token-parser\"));\nvar _sspiTokenParser = _interopRequireDefault(require(\"./sspi-token-parser\"));\nvar _helpers = require(\"./helpers\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nclass Parser {\n  static async *parseTokens(iterable, debug, options, colMetadata = []) {\n    const parser = new Parser(iterable, debug, options);\n    parser.colMetadata = colMetadata;\n    while (true) {\n      try {\n        await parser.waitForChunk();\n      } catch (err) {\n        if (parser.position === parser.buffer.length) {\n          return;\n        }\n        throw err;\n      }\n      while (parser.buffer.length >= parser.position + 1) {\n        const type = parser.buffer.readUInt8(parser.position);\n        parser.position += 1;\n        const token = parser.readToken(type);\n        if (token !== undefined) {\n          yield token;\n        }\n      }\n    }\n  }\n  readToken(type) {\n    switch (type) {\n      case _token.TYPE.DONE:\n        {\n          return this.readDoneToken();\n        }\n      case _token.TYPE.DONEPROC:\n        {\n          return this.readDoneProcToken();\n        }\n      case _token.TYPE.DONEINPROC:\n        {\n          return this.readDoneInProcToken();\n        }\n      case _token.TYPE.ERROR:\n        {\n          return this.readErrorToken();\n        }\n      case _token.TYPE.INFO:\n        {\n          return this.readInfoToken();\n        }\n      case _token.TYPE.ENVCHANGE:\n        {\n          return this.readEnvChangeToken();\n        }\n      case _token.TYPE.LOGINACK:\n        {\n          return this.readLoginAckToken();\n        }\n      case _token.TYPE.RETURNSTATUS:\n        {\n          return this.readReturnStatusToken();\n        }\n      case _token.TYPE.ORDER:\n        {\n          return this.readOrderToken();\n        }\n      case _token.TYPE.FEDAUTHINFO:\n        {\n          return this.readFedAuthInfoToken();\n        }\n      case _token.TYPE.SSPI:\n        {\n          return this.readSSPIToken();\n        }\n      case _token.TYPE.COLMETADATA:\n        {\n          return this.readColMetadataToken();\n        }\n      case _token.TYPE.RETURNVALUE:\n        {\n          return this.readReturnValueToken();\n        }\n      case _token.TYPE.ROW:\n        {\n          return this.readRowToken();\n        }\n      case _token.TYPE.NBCROW:\n        {\n          return this.readNbcRowToken();\n        }\n      case _token.TYPE.FEATUREEXTACK:\n        {\n          return this.readFeatureExtAckToken();\n        }\n      default:\n        {\n          throw new Error('Unknown type: ' + type);\n        }\n    }\n  }\n  readFeatureExtAckToken() {\n    let result;\n    try {\n      result = (0, _featureExtAckParser.default)(this.buffer, this.position, this.options);\n    } catch (err) {\n      if (err instanceof _helpers.NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readFeatureExtAckToken();\n        });\n      }\n      throw err;\n    }\n    this.position = result.offset;\n    return result.value;\n  }\n  async readNbcRowToken() {\n    return await (0, _nbcrowTokenParser.default)(this);\n  }\n  async readReturnValueToken() {\n    return await (0, _returnvalueTokenParser.default)(this);\n  }\n  async readColMetadataToken() {\n    const token = await (0, _colmetadataTokenParser.default)(this);\n    this.colMetadata = token.columns;\n    return token;\n  }\n  readSSPIToken() {\n    let result;\n    try {\n      result = (0, _sspiTokenParser.default)(this.buffer, this.position, this.options);\n    } catch (err) {\n      if (err instanceof _helpers.NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readSSPIToken();\n        });\n      }\n      throw err;\n    }\n    this.position = result.offset;\n    return result.value;\n  }\n  readFedAuthInfoToken() {\n    let result;\n    try {\n      result = (0, _fedauthInfoParser.default)(this.buffer, this.position, this.options);\n    } catch (err) {\n      if (err instanceof _helpers.NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readFedAuthInfoToken();\n        });\n      }\n      throw err;\n    }\n    this.position = result.offset;\n    return result.value;\n  }\n  readOrderToken() {\n    let result;\n    try {\n      result = (0, _orderTokenParser.default)(this.buffer, this.position, this.options);\n    } catch (err) {\n      if (err instanceof _helpers.NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readOrderToken();\n        });\n      }\n      throw err;\n    }\n    this.position = result.offset;\n    return result.value;\n  }\n  readReturnStatusToken() {\n    let result;\n    try {\n      result = (0, _returnstatusTokenParser.default)(this.buffer, this.position, this.options);\n    } catch (err) {\n      if (err instanceof _helpers.NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readReturnStatusToken();\n        });\n      }\n      throw err;\n    }\n    this.position = result.offset;\n    return result.value;\n  }\n  readLoginAckToken() {\n    let result;\n    try {\n      result = (0, _loginackTokenParser.default)(this.buffer, this.position, this.options);\n    } catch (err) {\n      if (err instanceof _helpers.NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readLoginAckToken();\n        });\n      }\n      throw err;\n    }\n    this.position = result.offset;\n    return result.value;\n  }\n  readEnvChangeToken() {\n    let result;\n    try {\n      result = (0, _envChangeTokenParser.default)(this.buffer, this.position, this.options);\n    } catch (err) {\n      if (err instanceof _helpers.NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readEnvChangeToken();\n        });\n      }\n      throw err;\n    }\n    this.position = result.offset;\n    return result.value;\n  }\n  readRowToken() {\n    return (0, _rowTokenParser.default)(this);\n  }\n  readInfoToken() {\n    let result;\n    try {\n      result = (0, _infoerrorTokenParser.infoParser)(this.buffer, this.position, this.options);\n    } catch (err) {\n      if (err instanceof _helpers.NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readInfoToken();\n        });\n      }\n      throw err;\n    }\n    this.position = result.offset;\n    return result.value;\n  }\n  readErrorToken() {\n    let result;\n    try {\n      result = (0, _infoerrorTokenParser.errorParser)(this.buffer, this.position, this.options);\n    } catch (err) {\n      if (err instanceof _helpers.NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readErrorToken();\n        });\n      }\n      throw err;\n    }\n    this.position = result.offset;\n    return result.value;\n  }\n  readDoneInProcToken() {\n    let result;\n    try {\n      result = (0, _doneTokenParser.doneInProcParser)(this.buffer, this.position, this.options);\n    } catch (err) {\n      if (err instanceof _helpers.NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readDoneInProcToken();\n        });\n      }\n      throw err;\n    }\n    this.position = result.offset;\n    return result.value;\n  }\n  readDoneProcToken() {\n    let result;\n    try {\n      result = (0, _doneTokenParser.doneProcParser)(this.buffer, this.position, this.options);\n    } catch (err) {\n      if (err instanceof _helpers.NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readDoneProcToken();\n        });\n      }\n      throw err;\n    }\n    this.position = result.offset;\n    return result.value;\n  }\n  readDoneToken() {\n    let result;\n    try {\n      result = (0, _doneTokenParser.doneParser)(this.buffer, this.position, this.options);\n    } catch (err) {\n      if (err instanceof _helpers.NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readDoneToken();\n        });\n      }\n      throw err;\n    }\n    this.position = result.offset;\n    return result.value;\n  }\n  constructor(iterable, debug, options) {\n    this.debug = debug;\n    this.colMetadata = [];\n    this.options = options;\n    this.iterator = (iterable[Symbol.asyncIterator] || iterable[Symbol.iterator]).call(iterable);\n    this.buffer = Buffer.alloc(0);\n    this.position = 0;\n  }\n  async waitForChunk() {\n    const result = await this.iterator.next();\n    if (result.done) {\n      throw new Error('unexpected end of data');\n    }\n    if (this.position === this.buffer.length) {\n      this.buffer = result.value;\n    } else {\n      this.buffer = Buffer.concat([this.buffer.slice(this.position), result.value]);\n    }\n    this.position = 0;\n  }\n}\nvar _default = exports.default = Parser;\nmodule.exports = Parser;","map":{"version":3,"names":["_token","require","_colmetadataTokenParser","_interopRequireDefault","_doneTokenParser","_envChangeTokenParser","_infoerrorTokenParser","_fedauthInfoParser","_featureExtAckParser","_loginackTokenParser","_orderTokenParser","_returnstatusTokenParser","_returnvalueTokenParser","_rowTokenParser","_nbcrowTokenParser","_sspiTokenParser","_helpers","obj","__esModule","default","Parser","parseTokens","iterable","debug","options","colMetadata","parser","waitForChunk","err","position","buffer","length","type","readUInt8","token","readToken","undefined","TYPE","DONE","readDoneToken","DONEPROC","readDoneProcToken","DONEINPROC","readDoneInProcToken","ERROR","readErrorToken","INFO","readInfoToken","ENVCHANGE","readEnvChangeToken","LOGINACK","readLoginAckToken","RETURNSTATUS","readReturnStatusToken","ORDER","readOrderToken","FEDAUTHINFO","readFedAuthInfoToken","SSPI","readSSPIToken","COLMETADATA","readColMetadataToken","RETURNVALUE","readReturnValueToken","ROW","readRowToken","NBCROW","readNbcRowToken","FEATUREEXTACK","readFeatureExtAckToken","Error","result","NotEnoughDataError","then","offset","value","columns","infoParser","errorParser","doneInProcParser","doneProcParser","doneParser","constructor","iterator","Symbol","asyncIterator","call","Buffer","alloc","next","done","concat","slice","_default","exports","module"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\tedious\\src\\token\\stream-parser.ts"],"sourcesContent":["import Debug from '../debug';\nimport { type InternalConnectionOptions } from '../connection';\n\nimport { TYPE, ColMetadataToken, DoneProcToken, DoneToken, DoneInProcToken, ErrorMessageToken, InfoMessageToken, RowToken, type EnvChangeToken, LoginAckToken, ReturnStatusToken, OrderToken, FedAuthInfoToken, SSPIToken, ReturnValueToken, NBCRowToken, FeatureExtAckToken, Token } from './token';\n\nimport colMetadataParser, { type ColumnMetadata } from './colmetadata-token-parser';\nimport { doneParser, doneInProcParser, doneProcParser } from './done-token-parser';\nimport envChangeParser from './env-change-token-parser';\nimport { errorParser, infoParser } from './infoerror-token-parser';\nimport fedAuthInfoParser from './fedauth-info-parser';\nimport featureExtAckParser from './feature-ext-ack-parser';\nimport loginAckParser from './loginack-token-parser';\nimport orderParser from './order-token-parser';\nimport returnStatusParser from './returnstatus-token-parser';\nimport returnValueParser from './returnvalue-token-parser';\nimport rowParser from './row-token-parser';\nimport nbcRowParser from './nbcrow-token-parser';\nimport sspiParser from './sspi-token-parser';\nimport { NotEnoughDataError } from './helpers';\n\nexport type ParserOptions = Pick<InternalConnectionOptions, 'useUTC' | 'lowerCaseGuids' | 'tdsVersion' | 'useColumnNames' | 'columnNameReplacer' | 'camelCaseColumns'>;\n\nclass Parser {\n  debug: Debug;\n  colMetadata: ColumnMetadata[];\n  options: ParserOptions;\n\n  iterator: AsyncIterator<Buffer, any, undefined> | Iterator<Buffer, any, undefined>;\n  buffer: Buffer;\n  position: number;\n\n  static async *parseTokens(iterable: AsyncIterable<Buffer> | Iterable<Buffer>, debug: Debug, options: ParserOptions, colMetadata: ColumnMetadata[] = []) {\n    const parser = new Parser(iterable, debug, options);\n    parser.colMetadata = colMetadata;\n\n    while (true) {\n      try {\n        await parser.waitForChunk();\n      } catch (err: unknown) {\n        if (parser.position === parser.buffer.length) {\n          return;\n        }\n\n        throw err;\n      }\n\n      while (parser.buffer.length >= parser.position + 1) {\n        const type = parser.buffer.readUInt8(parser.position);\n        parser.position += 1;\n\n        const token = parser.readToken(type);\n        if (token !== undefined) {\n          yield token;\n        }\n      }\n    }\n  }\n\n  readToken(type: number): Token | undefined | Promise<Token | undefined> {\n    switch (type) {\n      case TYPE.DONE: {\n        return this.readDoneToken();\n      }\n\n      case TYPE.DONEPROC: {\n        return this.readDoneProcToken();\n      }\n\n      case TYPE.DONEINPROC: {\n        return this.readDoneInProcToken();\n      }\n\n      case TYPE.ERROR: {\n        return this.readErrorToken();\n      }\n\n      case TYPE.INFO: {\n        return this.readInfoToken();\n      }\n\n      case TYPE.ENVCHANGE: {\n        return this.readEnvChangeToken();\n      }\n\n      case TYPE.LOGINACK: {\n        return this.readLoginAckToken();\n      }\n\n      case TYPE.RETURNSTATUS: {\n        return this.readReturnStatusToken();\n      }\n\n      case TYPE.ORDER: {\n        return this.readOrderToken();\n      }\n\n      case TYPE.FEDAUTHINFO: {\n        return this.readFedAuthInfoToken();\n      }\n\n      case TYPE.SSPI: {\n        return this.readSSPIToken();\n      }\n\n      case TYPE.COLMETADATA: {\n        return this.readColMetadataToken();\n      }\n\n      case TYPE.RETURNVALUE: {\n        return this.readReturnValueToken();\n      }\n\n      case TYPE.ROW: {\n        return this.readRowToken();\n      }\n\n      case TYPE.NBCROW: {\n        return this.readNbcRowToken();\n      }\n\n      case TYPE.FEATUREEXTACK: {\n        return this.readFeatureExtAckToken();\n      }\n\n      default: {\n        throw new Error('Unknown type: ' + type);\n      }\n    }\n  }\n\n  readFeatureExtAckToken(): FeatureExtAckToken | Promise<FeatureExtAckToken> {\n    let result;\n\n    try {\n      result = featureExtAckParser(this.buffer, this.position, this.options);\n    } catch (err: any) {\n      if (err instanceof NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readFeatureExtAckToken();\n        });\n      }\n\n      throw err;\n    }\n\n    this.position = result.offset;\n    return result.value;\n  }\n\n  async readNbcRowToken(): Promise<NBCRowToken> {\n    return await nbcRowParser(this);\n  }\n\n  async readReturnValueToken(): Promise<ReturnValueToken> {\n    return await returnValueParser(this);\n  }\n\n  async readColMetadataToken(): Promise<ColMetadataToken> {\n    const token = await colMetadataParser(this);\n    this.colMetadata = token.columns;\n    return token;\n  }\n\n  readSSPIToken(): SSPIToken | Promise<SSPIToken> {\n    let result;\n\n    try {\n      result = sspiParser(this.buffer, this.position, this.options);\n    } catch (err: any) {\n      if (err instanceof NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readSSPIToken();\n        });\n      }\n\n      throw err;\n    }\n\n    this.position = result.offset;\n    return result.value;\n  }\n\n  readFedAuthInfoToken(): FedAuthInfoToken | Promise<FedAuthInfoToken> {\n    let result;\n\n    try {\n      result = fedAuthInfoParser(this.buffer, this.position, this.options);\n    } catch (err: any) {\n      if (err instanceof NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readFedAuthInfoToken();\n        });\n      }\n\n      throw err;\n    }\n\n    this.position = result.offset;\n    return result.value;\n  }\n\n  readOrderToken(): OrderToken | Promise<OrderToken> {\n    let result;\n\n    try {\n      result = orderParser(this.buffer, this.position, this.options);\n    } catch (err: any) {\n      if (err instanceof NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readOrderToken();\n        });\n      }\n\n      throw err;\n    }\n\n    this.position = result.offset;\n    return result.value;\n  }\n\n  readReturnStatusToken(): ReturnStatusToken | Promise<ReturnStatusToken> {\n    let result;\n\n    try {\n      result = returnStatusParser(this.buffer, this.position, this.options);\n    } catch (err: any) {\n      if (err instanceof NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readReturnStatusToken();\n        });\n      }\n\n      throw err;\n    }\n\n    this.position = result.offset;\n    return result.value;\n  }\n\n  readLoginAckToken(): LoginAckToken | Promise<LoginAckToken> {\n    let result;\n\n    try {\n      result = loginAckParser(this.buffer, this.position, this.options);\n    } catch (err: any) {\n      if (err instanceof NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readLoginAckToken();\n        });\n      }\n\n      throw err;\n    }\n\n    this.position = result.offset;\n    return result.value;\n  }\n\n  readEnvChangeToken(): EnvChangeToken | undefined | Promise<EnvChangeToken | undefined> {\n    let result;\n\n    try {\n      result = envChangeParser(this.buffer, this.position, this.options);\n    } catch (err: any) {\n      if (err instanceof NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readEnvChangeToken();\n        });\n      }\n\n      throw err;\n    }\n\n    this.position = result.offset;\n    return result.value;\n  }\n\n  readRowToken(): RowToken | Promise<RowToken> {\n    return rowParser(this);\n  }\n\n  readInfoToken(): InfoMessageToken | Promise<InfoMessageToken> {\n    let result;\n\n    try {\n      result = infoParser(this.buffer, this.position, this.options);\n    } catch (err: any) {\n      if (err instanceof NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readInfoToken();\n        });\n      }\n\n      throw err;\n    }\n\n    this.position = result.offset;\n    return result.value;\n  }\n\n  readErrorToken(): ErrorMessageToken | Promise<ErrorMessageToken> {\n    let result;\n\n    try {\n      result = errorParser(this.buffer, this.position, this.options);\n    } catch (err: any) {\n      if (err instanceof NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readErrorToken();\n        });\n      }\n\n      throw err;\n    }\n\n    this.position = result.offset;\n    return result.value;\n  }\n\n  readDoneInProcToken(): DoneInProcToken | Promise<DoneInProcToken> {\n    let result;\n\n    try {\n      result = doneInProcParser(this.buffer, this.position, this.options);\n    } catch (err: any) {\n      if (err instanceof NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readDoneInProcToken();\n        });\n      }\n\n      throw err;\n    }\n\n    this.position = result.offset;\n    return result.value;\n  }\n\n  readDoneProcToken(): DoneProcToken | Promise<DoneProcToken> {\n    let result;\n\n    try {\n      result = doneProcParser(this.buffer, this.position, this.options);\n    } catch (err: any) {\n      if (err instanceof NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readDoneProcToken();\n        });\n      }\n\n      throw err;\n    }\n\n    this.position = result.offset;\n    return result.value;\n  }\n\n  readDoneToken(): DoneToken | Promise<DoneToken> {\n    let result;\n\n    try {\n      result = doneParser(this.buffer, this.position, this.options);\n    } catch (err: any) {\n      if (err instanceof NotEnoughDataError) {\n        return this.waitForChunk().then(() => {\n          return this.readDoneToken();\n        });\n      }\n\n      throw err;\n    }\n\n    this.position = result.offset;\n    return result.value;\n  }\n\n  constructor(iterable: AsyncIterable<Buffer> | Iterable<Buffer>, debug: Debug, options: ParserOptions) {\n    this.debug = debug;\n    this.colMetadata = [];\n    this.options = options;\n\n    this.iterator = ((iterable as AsyncIterable<Buffer>)[Symbol.asyncIterator] || (iterable as Iterable<Buffer>)[Symbol.iterator]).call(iterable);\n\n    this.buffer = Buffer.alloc(0);\n    this.position = 0;\n  }\n\n  async waitForChunk() {\n    const result = await this.iterator.next();\n    if (result.done) {\n      throw new Error('unexpected end of data');\n    }\n\n    if (this.position === this.buffer.length) {\n      this.buffer = result.value;\n    } else {\n      this.buffer = Buffer.concat([this.buffer.slice(this.position), result.value]);\n    }\n\n    this.position = 0;\n  }\n}\n\nexport default Parser;\nmodule.exports = Parser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}