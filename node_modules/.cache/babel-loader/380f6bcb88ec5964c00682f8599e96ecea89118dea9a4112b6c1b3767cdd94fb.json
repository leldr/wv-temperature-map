{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { checkTenantId, processMultiTenantRequest, resolveAdditionallyAllowedTenantIds } from \"../util/tenantIdUtils\";\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { credentialLogger, formatSuccess } from \"../util/logging\";\nimport { IdentityClient } from \"../client/identityClient\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { tracingClient } from \"../util/tracing\";\nconst logger = credentialLogger(\"UsernamePasswordCredential\");\n/**\n * Enables authentication to Microsoft Entra ID with a user's\n * username and password. This credential requires a high degree of\n * trust so you should only use it when other, more secure credential\n * types can't be used.\n */\nexport class UsernamePasswordCredential {\n  /**\n   * Creates an instance of the UsernamePasswordCredential with the details\n   * needed to authenticate against Microsoft Entra ID with a username\n   * and password.\n   *\n   * @param tenantIdOrName - The Microsoft Entra tenant (directory) ID or name.\n   * @param clientId - The client (application) ID of an App Registration in the tenant.\n   * @param username - The user account's e-mail address (user name).\n   * @param password - The user account's account password\n   * @param options - Options for configuring the client which makes the authentication request.\n   */\n  constructor(tenantIdOrName, clientId, username, password, options) {\n    checkTenantId(logger, tenantIdOrName);\n    this.identityClient = new IdentityClient(options);\n    this.tenantId = tenantIdOrName;\n    this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);\n    this.clientId = clientId;\n    this.username = username;\n    this.password = password;\n  }\n  /**\n   * Authenticates with Microsoft Entra ID and returns an access token if\n   * successful.  If authentication cannot be performed at this time, this method may\n   * return null.  If an error occurs during authentication, an {@link AuthenticationError}\n   * containing failure details will be thrown.\n   *\n   * @param scopes - The list of scopes for which the token will have access.\n   * @param options - The options used to configure any requests this\n   *                TokenCredential implementation might make.\n   */\n  async getToken(scopes, options = {}) {\n    return tracingClient.withSpan(\"UsernamePasswordCredential.getToken\", options, async newOptions => {\n      const tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds);\n      newOptions.tenantId = tenantId;\n      const urlSuffix = getIdentityTokenEndpointSuffix(this.tenantId);\n      const params = new URLSearchParams({\n        response_type: \"token\",\n        grant_type: \"password\",\n        client_id: this.clientId,\n        username: this.username,\n        password: this.password,\n        scope: typeof scopes === \"string\" ? scopes : scopes.join(\" \")\n      });\n      const webResource = createPipelineRequest({\n        url: `${this.identityClient.authorityHost}/${this.tenantId}/${urlSuffix}`,\n        method: \"POST\",\n        body: params.toString(),\n        headers: createHttpHeaders({\n          Accept: \"application/json\",\n          \"Content-Type\": \"application/x-www-form-urlencoded\"\n        }),\n        abortSignal: options && options.abortSignal,\n        tracingOptions: newOptions.tracingOptions\n      });\n      const tokenResponse = await this.identityClient.sendTokenRequest(webResource);\n      logger.getToken.info(formatSuccess(scopes));\n      return tokenResponse && tokenResponse.accessToken || null;\n    });\n  }\n}","map":{"version":3,"names":["checkTenantId","processMultiTenantRequest","resolveAdditionallyAllowedTenantIds","createHttpHeaders","createPipelineRequest","credentialLogger","formatSuccess","IdentityClient","getIdentityTokenEndpointSuffix","tracingClient","logger","UsernamePasswordCredential","constructor","tenantIdOrName","clientId","username","password","options","identityClient","tenantId","additionallyAllowedTenantIds","additionallyAllowedTenants","getToken","scopes","withSpan","newOptions","urlSuffix","params","URLSearchParams","response_type","grant_type","client_id","scope","join","webResource","url","authorityHost","method","body","toString","headers","Accept","abortSignal","tracingOptions","tokenResponse","sendTokenRequest","info","accessToken"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\@azure\\identity\\src\\credentials\\usernamePasswordCredential.browser.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AccessToken, GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\nimport {\n  checkTenantId,\n  processMultiTenantRequest,\n  resolveAdditionallyAllowedTenantIds,\n} from \"../util/tenantIdUtils\";\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { credentialLogger, formatSuccess } from \"../util/logging\";\nimport { IdentityClient } from \"../client/identityClient\";\nimport { UsernamePasswordCredentialOptions } from \"./usernamePasswordCredentialOptions\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { tracingClient } from \"../util/tracing\";\n\nconst logger = credentialLogger(\"UsernamePasswordCredential\");\n\n/**\n * Enables authentication to Microsoft Entra ID with a user's\n * username and password. This credential requires a high degree of\n * trust so you should only use it when other, more secure credential\n * types can't be used.\n */\nexport class UsernamePasswordCredential implements TokenCredential {\n  private identityClient: IdentityClient;\n  private tenantId: string;\n  private additionallyAllowedTenantIds: string[];\n  private clientId: string;\n  private username: string;\n  private password: string;\n\n  /**\n   * Creates an instance of the UsernamePasswordCredential with the details\n   * needed to authenticate against Microsoft Entra ID with a username\n   * and password.\n   *\n   * @param tenantIdOrName - The Microsoft Entra tenant (directory) ID or name.\n   * @param clientId - The client (application) ID of an App Registration in the tenant.\n   * @param username - The user account's e-mail address (user name).\n   * @param password - The user account's account password\n   * @param options - Options for configuring the client which makes the authentication request.\n   */\n  constructor(\n    tenantIdOrName: string,\n    clientId: string,\n    username: string,\n    password: string,\n    options?: UsernamePasswordCredentialOptions,\n  ) {\n    checkTenantId(logger, tenantIdOrName);\n\n    this.identityClient = new IdentityClient(options);\n    this.tenantId = tenantIdOrName;\n    this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(\n      options?.additionallyAllowedTenants,\n    );\n    this.clientId = clientId;\n    this.username = username;\n    this.password = password;\n  }\n\n  /**\n   * Authenticates with Microsoft Entra ID and returns an access token if\n   * successful.  If authentication cannot be performed at this time, this method may\n   * return null.  If an error occurs during authentication, an {@link AuthenticationError}\n   * containing failure details will be thrown.\n   *\n   * @param scopes - The list of scopes for which the token will have access.\n   * @param options - The options used to configure any requests this\n   *                TokenCredential implementation might make.\n   */\n  public async getToken(\n    scopes: string | string[],\n    options: GetTokenOptions = {},\n  ): Promise<AccessToken | null> {\n    return tracingClient.withSpan(\n      \"UsernamePasswordCredential.getToken\",\n      options,\n      async (newOptions) => {\n        const tenantId = processMultiTenantRequest(\n          this.tenantId,\n          newOptions,\n          this.additionallyAllowedTenantIds,\n        );\n        newOptions.tenantId = tenantId;\n\n        const urlSuffix = getIdentityTokenEndpointSuffix(this.tenantId);\n        const params = new URLSearchParams({\n          response_type: \"token\",\n          grant_type: \"password\",\n          client_id: this.clientId,\n          username: this.username,\n          password: this.password,\n          scope: typeof scopes === \"string\" ? scopes : scopes.join(\" \"),\n        });\n        const webResource = createPipelineRequest({\n          url: `${this.identityClient.authorityHost}/${this.tenantId}/${urlSuffix}`,\n          method: \"POST\",\n          body: params.toString(),\n          headers: createHttpHeaders({\n            Accept: \"application/json\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n          }),\n          abortSignal: options && options.abortSignal,\n          tracingOptions: newOptions.tracingOptions,\n        });\n\n        const tokenResponse = await this.identityClient.sendTokenRequest(webResource);\n        logger.getToken.info(formatSuccess(scopes));\n        return (tokenResponse && tokenResponse.accessToken) || null;\n      },\n    );\n  }\n}\n"],"mappings":"AAAA;AACA;AAGA,SACEA,aAAa,EACbC,yBAAyB,EACzBC,mCAAmC,QAC9B,uBAAuB;AAC9B,SAASC,iBAAiB,EAAEC,qBAAqB,QAAQ,2BAA2B;AACpF,SAASC,gBAAgB,EAAEC,aAAa,QAAQ,iBAAiB;AACjE,SAASC,cAAc,QAAQ,0BAA0B;AAEzD,SAASC,8BAA8B,QAAQ,+BAA+B;AAC9E,SAASC,aAAa,QAAQ,iBAAiB;AAE/C,MAAMC,MAAM,GAAGL,gBAAgB,CAAC,4BAA4B,CAAC;AAE7D;;;;;;AAMA,OAAM,MAAOM,0BAA0B;EAQrC;;;;;;;;;;;EAWAC,YACEC,cAAsB,EACtBC,QAAgB,EAChBC,QAAgB,EAChBC,QAAgB,EAChBC,OAA2C;IAE3CjB,aAAa,CAACU,MAAM,EAAEG,cAAc,CAAC;IAErC,IAAI,CAACK,cAAc,GAAG,IAAIX,cAAc,CAACU,OAAO,CAAC;IACjD,IAAI,CAACE,QAAQ,GAAGN,cAAc;IAC9B,IAAI,CAACO,4BAA4B,GAAGlB,mCAAmC,CACrEe,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEI,0BAA0B,CACpC;IACD,IAAI,CAACP,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;EAC1B;EAEA;;;;;;;;;;EAUO,MAAMM,QAAQA,CACnBC,MAAyB,EACzBN,OAAA,GAA2B,EAAE;IAE7B,OAAOR,aAAa,CAACe,QAAQ,CAC3B,qCAAqC,EACrCP,OAAO,EACP,MAAOQ,UAAU,IAAI;MACnB,MAAMN,QAAQ,GAAGlB,yBAAyB,CACxC,IAAI,CAACkB,QAAQ,EACbM,UAAU,EACV,IAAI,CAACL,4BAA4B,CAClC;MACDK,UAAU,CAACN,QAAQ,GAAGA,QAAQ;MAE9B,MAAMO,SAAS,GAAGlB,8BAA8B,CAAC,IAAI,CAACW,QAAQ,CAAC;MAC/D,MAAMQ,MAAM,GAAG,IAAIC,eAAe,CAAC;QACjCC,aAAa,EAAE,OAAO;QACtBC,UAAU,EAAE,UAAU;QACtBC,SAAS,EAAE,IAAI,CAACjB,QAAQ;QACxBC,QAAQ,EAAE,IAAI,CAACA,QAAQ;QACvBC,QAAQ,EAAE,IAAI,CAACA,QAAQ;QACvBgB,KAAK,EAAE,OAAOT,MAAM,KAAK,QAAQ,GAAGA,MAAM,GAAGA,MAAM,CAACU,IAAI,CAAC,GAAG;OAC7D,CAAC;MACF,MAAMC,WAAW,GAAG9B,qBAAqB,CAAC;QACxC+B,GAAG,EAAE,GAAG,IAAI,CAACjB,cAAc,CAACkB,aAAa,IAAI,IAAI,CAACjB,QAAQ,IAAIO,SAAS,EAAE;QACzEW,MAAM,EAAE,MAAM;QACdC,IAAI,EAAEX,MAAM,CAACY,QAAQ,EAAE;QACvBC,OAAO,EAAErC,iBAAiB,CAAC;UACzBsC,MAAM,EAAE,kBAAkB;UAC1B,cAAc,EAAE;SACjB,CAAC;QACFC,WAAW,EAAEzB,OAAO,IAAIA,OAAO,CAACyB,WAAW;QAC3CC,cAAc,EAAElB,UAAU,CAACkB;OAC5B,CAAC;MAEF,MAAMC,aAAa,GAAG,MAAM,IAAI,CAAC1B,cAAc,CAAC2B,gBAAgB,CAACX,WAAW,CAAC;MAC7ExB,MAAM,CAACY,QAAQ,CAACwB,IAAI,CAACxC,aAAa,CAACiB,MAAM,CAAC,CAAC;MAC3C,OAAQqB,aAAa,IAAIA,aAAa,CAACG,WAAW,IAAK,IAAI;IAC7D,CAAC,CACF;EACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}