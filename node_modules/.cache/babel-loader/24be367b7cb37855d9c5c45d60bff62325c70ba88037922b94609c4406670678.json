{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _token = require(\"./token\");\nvar _metadataParser = require(\"../metadata-parser\");\nvar _valueParser = require(\"../value-parser\");\nvar _helpers = require(\"./helpers\");\nvar iconv = _interopRequireWildcard(require(\"iconv-lite\"));\nfunction _getRequireWildcardCache(e) {\n  if (\"function\" != typeof WeakMap) return null;\n  var r = new WeakMap(),\n    t = new WeakMap();\n  return (_getRequireWildcardCache = function (e) {\n    return e ? t : r;\n  })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n  if (!r && e && e.__esModule) return e;\n  if (null === e || \"object\" != typeof e && \"function\" != typeof e) return {\n    default: e\n  };\n  var t = _getRequireWildcardCache(r);\n  if (t && t.has(e)) return t.get(e);\n  var n = {\n      __proto__: null\n    },\n    a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) {\n    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n  }\n  return n.default = e, t && t.set(e, n), n;\n}\n// s2.2.7.16\n\nasync function returnParser(parser) {\n  let paramName;\n  let paramOrdinal;\n  let metadata;\n  while (true) {\n    const buf = parser.buffer;\n    let offset = parser.position;\n    try {\n      ({\n        offset,\n        value: paramOrdinal\n      } = (0, _helpers.readUInt16LE)(buf, offset));\n      ({\n        offset,\n        value: paramName\n      } = (0, _helpers.readBVarChar)(buf, offset));\n      // status\n      ({\n        offset\n      } = (0, _helpers.readUInt8)(buf, offset));\n      ({\n        offset,\n        value: metadata\n      } = (0, _metadataParser.readMetadata)(buf, offset, parser.options));\n      if (paramName.charAt(0) === '@') {\n        paramName = paramName.slice(1);\n      }\n    } catch (err) {\n      if (err instanceof _helpers.NotEnoughDataError) {\n        await parser.waitForChunk();\n        continue;\n      }\n      throw err;\n    }\n    parser.position = offset;\n    break;\n  }\n  let value;\n  while (true) {\n    const buf = parser.buffer;\n    let offset = parser.position;\n    if ((0, _valueParser.isPLPStream)(metadata)) {\n      const chunks = await (0, _valueParser.readPLPStream)(parser);\n      if (chunks === null) {\n        value = chunks;\n      } else if (metadata.type.name === 'NVarChar' || metadata.type.name === 'Xml') {\n        value = Buffer.concat(chunks).toString('ucs2');\n      } else if (metadata.type.name === 'VarChar') {\n        var _metadata$collation$c, _metadata$collation;\n        value = iconv.decode(Buffer.concat(chunks), (_metadata$collation$c = (_metadata$collation = metadata.collation) === null || _metadata$collation === void 0 ? void 0 : _metadata$collation.codepage) !== null && _metadata$collation$c !== void 0 ? _metadata$collation$c : 'utf8');\n      } else if (metadata.type.name === 'VarBinary' || metadata.type.name === 'UDT') {\n        value = Buffer.concat(chunks);\n      }\n    } else {\n      try {\n        ({\n          value,\n          offset\n        } = (0, _valueParser.readValue)(buf, offset, metadata, parser.options));\n      } catch (err) {\n        if (err instanceof _helpers.NotEnoughDataError) {\n          await parser.waitForChunk();\n          continue;\n        }\n        throw err;\n      }\n      parser.position = offset;\n    }\n    break;\n  }\n  return new _token.ReturnValueToken({\n    paramOrdinal: paramOrdinal,\n    paramName: paramName,\n    metadata: metadata,\n    value: value\n  });\n}\nvar _default = exports.default = returnParser;\nmodule.exports = returnParser;","map":{"version":3,"names":["_token","require","_metadataParser","_valueParser","_helpers","iconv","_interopRequireWildcard","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","prototype","hasOwnProperty","call","i","set","returnParser","parser","paramName","paramOrdinal","metadata","buf","buffer","offset","position","value","readUInt16LE","readBVarChar","readUInt8","readMetadata","options","charAt","slice","err","NotEnoughDataError","waitForChunk","isPLPStream","chunks","readPLPStream","type","name","Buffer","concat","toString","_metadata$collation$c","_metadata$collation","decode","collation","codepage","readValue","ReturnValueToken","_default","exports","module"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\tedious\\src\\token\\returnvalue-token-parser.ts"],"sourcesContent":["// s2.2.7.16\n\nimport Parser from './stream-parser';\n\nimport { ReturnValueToken } from './token';\n\nimport { readMetadata } from '../metadata-parser';\nimport { isPLPStream, readPLPStream, readValue } from '../value-parser';\nimport { NotEnoughDataError, readBVarChar, readUInt16LE, readUInt8 } from './helpers';\nimport * as iconv from 'iconv-lite';\n\nasync function returnParser(parser: Parser): Promise<ReturnValueToken> {\n  let paramName;\n  let paramOrdinal;\n  let metadata;\n\n  while (true) {\n    const buf = parser.buffer;\n    let offset = parser.position;\n\n    try {\n      ({ offset, value: paramOrdinal } = readUInt16LE(buf, offset));\n      ({ offset, value: paramName } = readBVarChar(buf, offset));\n      // status\n      ({ offset } = readUInt8(buf, offset));\n      ({ offset, value: metadata } = readMetadata(buf, offset, parser.options));\n\n      if (paramName.charAt(0) === '@') {\n        paramName = paramName.slice(1);\n      }\n    } catch (err) {\n      if (err instanceof NotEnoughDataError) {\n        await parser.waitForChunk();\n        continue;\n      }\n\n      throw err;\n    }\n\n    parser.position = offset;\n    break;\n  }\n\n  let value;\n  while (true) {\n    const buf = parser.buffer;\n    let offset = parser.position;\n\n    if (isPLPStream(metadata)) {\n      const chunks = await readPLPStream(parser);\n\n      if (chunks === null) {\n        value = chunks;\n      } else if (metadata.type.name === 'NVarChar' || metadata.type.name === 'Xml') {\n        value = Buffer.concat(chunks).toString('ucs2');\n      } else if (metadata.type.name === 'VarChar') {\n        value = iconv.decode(Buffer.concat(chunks), metadata.collation?.codepage ?? 'utf8');\n      } else if (metadata.type.name === 'VarBinary' || metadata.type.name === 'UDT') {\n        value = Buffer.concat(chunks);\n      }\n    } else {\n      try {\n        ({ value, offset } = readValue(buf, offset, metadata, parser.options));\n      } catch (err) {\n        if (err instanceof NotEnoughDataError) {\n          await parser.waitForChunk();\n          continue;\n        }\n\n        throw err;\n      }\n\n      parser.position = offset;\n    }\n\n    break;\n  }\n\n  return new ReturnValueToken({\n    paramOrdinal: paramOrdinal,\n    paramName: paramName,\n    metadata: metadata,\n    value: value\n  });\n}\n\nexport default returnParser;\nmodule.exports = returnParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}