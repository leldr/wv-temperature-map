{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { AggregateAuthenticationError, CredentialUnavailableError } from \"../errors\";\nimport { credentialLogger, formatError, formatSuccess } from \"../util/logging\";\nimport { tracingClient } from \"../util/tracing\";\n/**\n * @internal\n */\nexport const logger = credentialLogger(\"ChainedTokenCredential\");\n/**\n * Enables multiple `TokenCredential` implementations to be tried in order\n * until one of the getToken methods returns an access token.\n */\nexport class ChainedTokenCredential {\n  /**\n   * Creates an instance of ChainedTokenCredential using the given credentials.\n   *\n   * @param sources - `TokenCredential` implementations to be tried in order.\n   *\n   * Example usage:\n   * ```ts snippet:chained_token_credential_example\n   * import { ClientSecretCredential, ChainedTokenCredential } from \"@azure/identity\";\n   *\n   * const tenantId = \"<tenant-id>\";\n   * const clientId = \"<client-id>\";\n   * const clientSecret = \"<client-secret>\";\n   * const anotherClientId = \"<another-client-id>\";\n   * const anotherSecret = \"<another-client-secret>\";\n   * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);\n   * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);\n   * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);\n   * ```\n   */\n  constructor(...sources) {\n    this._sources = [];\n    this._sources = sources;\n  }\n  /**\n   * Returns the first access token returned by one of the chained\n   * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}\n   * when one or more credentials throws an {@link AuthenticationError} and\n   * no credentials have returned an access token.\n   *\n   * This method is called automatically by Azure SDK client libraries. You may call this method\n   * directly, but you must also handle token caching and token refreshing.\n   *\n   * @param scopes - The list of scopes for which the token will have access.\n   * @param options - The options used to configure any requests this\n   *                `TokenCredential` implementation might make.\n   */\n  async getToken(scopes, options = {}) {\n    const {\n      token\n    } = await this.getTokenInternal(scopes, options);\n    return token;\n  }\n  async getTokenInternal(scopes, options = {}) {\n    let token = null;\n    let successfulCredential;\n    const errors = [];\n    return tracingClient.withSpan(\"ChainedTokenCredential.getToken\", options, async updatedOptions => {\n      for (let i = 0; i < this._sources.length && token === null; i++) {\n        try {\n          token = await this._sources[i].getToken(scopes, updatedOptions);\n          successfulCredential = this._sources[i];\n        } catch (err) {\n          if (err.name === \"CredentialUnavailableError\" || err.name === \"AuthenticationRequiredError\") {\n            errors.push(err);\n          } else {\n            logger.getToken.info(formatError(scopes, err));\n            throw err;\n          }\n        }\n      }\n      if (!token && errors.length > 0) {\n        const err = new AggregateAuthenticationError(errors, \"ChainedTokenCredential authentication failed.\");\n        logger.getToken.info(formatError(scopes, err));\n        throw err;\n      }\n      logger.getToken.info(`Result for ${successfulCredential.constructor.name}: ${formatSuccess(scopes)}`);\n      if (token === null) {\n        throw new CredentialUnavailableError(\"Failed to retrieve a valid token\");\n      }\n      return {\n        token,\n        successfulCredential\n      };\n    });\n  }\n}","map":{"version":3,"names":["AggregateAuthenticationError","CredentialUnavailableError","credentialLogger","formatError","formatSuccess","tracingClient","logger","ChainedTokenCredential","constructor","sources","_sources","getToken","scopes","options","token","getTokenInternal","successfulCredential","errors","withSpan","updatedOptions","i","length","err","name","push","info"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\@azure\\identity\\src\\credentials\\chainedTokenCredential.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AccessToken, GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\nimport { AggregateAuthenticationError, CredentialUnavailableError } from \"../errors\";\nimport { credentialLogger, formatError, formatSuccess } from \"../util/logging\";\nimport { tracingClient } from \"../util/tracing\";\n\n/**\n * @internal\n */\nexport const logger = credentialLogger(\"ChainedTokenCredential\");\n\n/**\n * Enables multiple `TokenCredential` implementations to be tried in order\n * until one of the getToken methods returns an access token.\n */\nexport class ChainedTokenCredential implements TokenCredential {\n  private _sources: TokenCredential[] = [];\n\n  /**\n   * Creates an instance of ChainedTokenCredential using the given credentials.\n   *\n   * @param sources - `TokenCredential` implementations to be tried in order.\n   *\n   * Example usage:\n   * ```ts snippet:chained_token_credential_example\n   * import { ClientSecretCredential, ChainedTokenCredential } from \"@azure/identity\";\n   *\n   * const tenantId = \"<tenant-id>\";\n   * const clientId = \"<client-id>\";\n   * const clientSecret = \"<client-secret>\";\n   * const anotherClientId = \"<another-client-id>\";\n   * const anotherSecret = \"<another-client-secret>\";\n   * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);\n   * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);\n   * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);\n   * ```\n   */\n  constructor(...sources: TokenCredential[]) {\n    this._sources = sources;\n  }\n\n  /**\n   * Returns the first access token returned by one of the chained\n   * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}\n   * when one or more credentials throws an {@link AuthenticationError} and\n   * no credentials have returned an access token.\n   *\n   * This method is called automatically by Azure SDK client libraries. You may call this method\n   * directly, but you must also handle token caching and token refreshing.\n   *\n   * @param scopes - The list of scopes for which the token will have access.\n   * @param options - The options used to configure any requests this\n   *                `TokenCredential` implementation might make.\n   */\n  async getToken(scopes: string | string[], options: GetTokenOptions = {}): Promise<AccessToken> {\n    const { token } = await this.getTokenInternal(scopes, options);\n    return token;\n  }\n\n  private async getTokenInternal(\n    scopes: string | string[],\n    options: GetTokenOptions = {},\n  ): Promise<{ token: AccessToken; successfulCredential: TokenCredential }> {\n    let token: AccessToken | null = null;\n    let successfulCredential: TokenCredential;\n    const errors: Error[] = [];\n\n    return tracingClient.withSpan(\n      \"ChainedTokenCredential.getToken\",\n      options,\n      async (updatedOptions) => {\n        for (let i = 0; i < this._sources.length && token === null; i++) {\n          try {\n            token = await this._sources[i].getToken(scopes, updatedOptions);\n            successfulCredential = this._sources[i];\n          } catch (err: any) {\n            if (\n              err.name === \"CredentialUnavailableError\" ||\n              err.name === \"AuthenticationRequiredError\"\n            ) {\n              errors.push(err);\n            } else {\n              logger.getToken.info(formatError(scopes, err));\n              throw err;\n            }\n          }\n        }\n\n        if (!token && errors.length > 0) {\n          const err = new AggregateAuthenticationError(\n            errors,\n            \"ChainedTokenCredential authentication failed.\",\n          );\n          logger.getToken.info(formatError(scopes, err));\n          throw err;\n        }\n\n        logger.getToken.info(\n          `Result for ${successfulCredential.constructor.name}: ${formatSuccess(scopes)}`,\n        );\n\n        if (token === null) {\n          throw new CredentialUnavailableError(\"Failed to retrieve a valid token\");\n        }\n        return { token, successfulCredential };\n      },\n    );\n  }\n}\n"],"mappings":"AAAA;AACA;AAGA,SAASA,4BAA4B,EAAEC,0BAA0B,QAAQ,WAAW;AACpF,SAASC,gBAAgB,EAAEC,WAAW,EAAEC,aAAa,QAAQ,iBAAiB;AAC9E,SAASC,aAAa,QAAQ,iBAAiB;AAE/C;;;AAGA,OAAO,MAAMC,MAAM,GAAGJ,gBAAgB,CAAC,wBAAwB,CAAC;AAEhE;;;;AAIA,OAAM,MAAOK,sBAAsB;EAGjC;;;;;;;;;;;;;;;;;;;EAmBAC,YAAY,GAAGC,OAA0B;IArBjC,KAAAC,QAAQ,GAAsB,EAAE;IAsBtC,IAAI,CAACA,QAAQ,GAAGD,OAAO;EACzB;EAEA;;;;;;;;;;;;;EAaA,MAAME,QAAQA,CAACC,MAAyB,EAAEC,OAAA,GAA2B,EAAE;IACrE,MAAM;MAAEC;IAAK,CAAE,GAAG,MAAM,IAAI,CAACC,gBAAgB,CAACH,MAAM,EAAEC,OAAO,CAAC;IAC9D,OAAOC,KAAK;EACd;EAEQ,MAAMC,gBAAgBA,CAC5BH,MAAyB,EACzBC,OAAA,GAA2B,EAAE;IAE7B,IAAIC,KAAK,GAAuB,IAAI;IACpC,IAAIE,oBAAqC;IACzC,MAAMC,MAAM,GAAY,EAAE;IAE1B,OAAOZ,aAAa,CAACa,QAAQ,CAC3B,iCAAiC,EACjCL,OAAO,EACP,MAAOM,cAAc,IAAI;MACvB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACV,QAAQ,CAACW,MAAM,IAAIP,KAAK,KAAK,IAAI,EAAEM,CAAC,EAAE,EAAE;QAC/D,IAAI;UACFN,KAAK,GAAG,MAAM,IAAI,CAACJ,QAAQ,CAACU,CAAC,CAAC,CAACT,QAAQ,CAACC,MAAM,EAAEO,cAAc,CAAC;UAC/DH,oBAAoB,GAAG,IAAI,CAACN,QAAQ,CAACU,CAAC,CAAC;QACzC,CAAC,CAAC,OAAOE,GAAQ,EAAE;UACjB,IACEA,GAAG,CAACC,IAAI,KAAK,4BAA4B,IACzCD,GAAG,CAACC,IAAI,KAAK,6BAA6B,EAC1C;YACAN,MAAM,CAACO,IAAI,CAACF,GAAG,CAAC;UAClB,CAAC,MAAM;YACLhB,MAAM,CAACK,QAAQ,CAACc,IAAI,CAACtB,WAAW,CAACS,MAAM,EAAEU,GAAG,CAAC,CAAC;YAC9C,MAAMA,GAAG;UACX;QACF;MACF;MAEA,IAAI,CAACR,KAAK,IAAIG,MAAM,CAACI,MAAM,GAAG,CAAC,EAAE;QAC/B,MAAMC,GAAG,GAAG,IAAItB,4BAA4B,CAC1CiB,MAAM,EACN,+CAA+C,CAChD;QACDX,MAAM,CAACK,QAAQ,CAACc,IAAI,CAACtB,WAAW,CAACS,MAAM,EAAEU,GAAG,CAAC,CAAC;QAC9C,MAAMA,GAAG;MACX;MAEAhB,MAAM,CAACK,QAAQ,CAACc,IAAI,CAClB,cAAcT,oBAAoB,CAACR,WAAW,CAACe,IAAI,KAAKnB,aAAa,CAACQ,MAAM,CAAC,EAAE,CAChF;MAED,IAAIE,KAAK,KAAK,IAAI,EAAE;QAClB,MAAM,IAAIb,0BAA0B,CAAC,kCAAkC,CAAC;MAC1E;MACA,OAAO;QAAEa,KAAK;QAAEE;MAAoB,CAAE;IACxC,CAAC,CACF;EACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}