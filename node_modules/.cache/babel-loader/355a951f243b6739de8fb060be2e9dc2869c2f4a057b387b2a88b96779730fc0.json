{"ast":null,"code":"\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that\n// correspond to encoded bytes (if 128 - then lower half is ASCII). \n\nexports._sbcs = SBCSCodec;\nfunction SBCSCodec(codecOptions, iconv) {\n  if (!codecOptions) throw new Error(\"SBCS codec is called without the data.\");\n\n  // Prepare char buffer for decoding.\n  if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error(\"Encoding '\" + codecOptions.type + \"' has incorrect 'chars' (must be of len 128 or 256)\");\n  if (codecOptions.chars.length === 128) {\n    var asciiString = \"\";\n    for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);\n    codecOptions.chars = asciiString + codecOptions.chars;\n  }\n  this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');\n\n  // Encoding buffer.\n  var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));\n  for (var i = 0; i < codecOptions.chars.length; i++) encodeBuf[codecOptions.chars.charCodeAt(i)] = i;\n  this.encodeBuf = encodeBuf;\n}\n_c = SBCSCodec;\nSBCSCodec.prototype.encoder = SBCSEncoder;\nSBCSCodec.prototype.decoder = SBCSDecoder;\nfunction SBCSEncoder(options, codec) {\n  this.encodeBuf = codec.encodeBuf;\n}\n_c2 = SBCSEncoder;\nSBCSEncoder.prototype.write = function (str) {\n  var buf = Buffer.alloc(str.length);\n  for (var i = 0; i < str.length; i++) buf[i] = this.encodeBuf[str.charCodeAt(i)];\n  return buf;\n};\nSBCSEncoder.prototype.end = function () {};\nfunction SBCSDecoder(options, codec) {\n  this.decodeBuf = codec.decodeBuf;\n}\n_c3 = SBCSDecoder;\nSBCSDecoder.prototype.write = function (buf) {\n  // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.\n  var decodeBuf = this.decodeBuf;\n  var newBuf = Buffer.alloc(buf.length * 2);\n  var idx1 = 0,\n    idx2 = 0;\n  for (var i = 0; i < buf.length; i++) {\n    idx1 = buf[i] * 2;\n    idx2 = i * 2;\n    newBuf[idx2] = decodeBuf[idx1];\n    newBuf[idx2 + 1] = decodeBuf[idx1 + 1];\n  }\n  return newBuf.toString('ucs2');\n};\nSBCSDecoder.prototype.end = function () {};\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"SBCSCodec\");\n$RefreshReg$(_c2, \"SBCSEncoder\");\n$RefreshReg$(_c3, \"SBCSDecoder\");","map":{"version":3,"names":["Buffer","require","exports","_sbcs","SBCSCodec","codecOptions","iconv","Error","chars","length","type","asciiString","i","String","fromCharCode","decodeBuf","from","encodeBuf","alloc","defaultCharSingleByte","charCodeAt","_c","prototype","encoder","SBCSEncoder","decoder","SBCSDecoder","options","codec","_c2","write","str","buf","end","_c3","newBuf","idx1","idx2","toString","$RefreshReg$"],"sources":["C:/Users/phlos/wv-temperature-map/src/backend/node_modules/iconv-lite/encodings/sbcs-codec.js"],"sourcesContent":["\"use strict\";\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that\n// correspond to encoded bytes (if 128 - then lower half is ASCII). \n\nexports._sbcs = SBCSCodec;\nfunction SBCSCodec(codecOptions, iconv) {\n    if (!codecOptions)\n        throw new Error(\"SBCS codec is called without the data.\")\n    \n    // Prepare char buffer for decoding.\n    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))\n        throw new Error(\"Encoding '\"+codecOptions.type+\"' has incorrect 'chars' (must be of len 128 or 256)\");\n    \n    if (codecOptions.chars.length === 128) {\n        var asciiString = \"\";\n        for (var i = 0; i < 128; i++)\n            asciiString += String.fromCharCode(i);\n        codecOptions.chars = asciiString + codecOptions.chars;\n    }\n\n    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');\n    \n    // Encoding buffer.\n    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));\n\n    for (var i = 0; i < codecOptions.chars.length; i++)\n        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;\n\n    this.encodeBuf = encodeBuf;\n}\n\nSBCSCodec.prototype.encoder = SBCSEncoder;\nSBCSCodec.prototype.decoder = SBCSDecoder;\n\n\nfunction SBCSEncoder(options, codec) {\n    this.encodeBuf = codec.encodeBuf;\n}\n\nSBCSEncoder.prototype.write = function(str) {\n    var buf = Buffer.alloc(str.length);\n    for (var i = 0; i < str.length; i++)\n        buf[i] = this.encodeBuf[str.charCodeAt(i)];\n    \n    return buf;\n}\n\nSBCSEncoder.prototype.end = function() {\n}\n\n\nfunction SBCSDecoder(options, codec) {\n    this.decodeBuf = codec.decodeBuf;\n}\n\nSBCSDecoder.prototype.write = function(buf) {\n    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.\n    var decodeBuf = this.decodeBuf;\n    var newBuf = Buffer.alloc(buf.length*2);\n    var idx1 = 0, idx2 = 0;\n    for (var i = 0; i < buf.length; i++) {\n        idx1 = buf[i]*2; idx2 = i*2;\n        newBuf[idx2] = decodeBuf[idx1];\n        newBuf[idx2+1] = decodeBuf[idx1+1];\n    }\n    return newBuf.toString('ucs2');\n}\n\nSBCSDecoder.prototype.end = function() {\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}