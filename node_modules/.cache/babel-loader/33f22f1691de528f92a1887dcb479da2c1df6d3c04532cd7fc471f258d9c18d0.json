{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { isNodeLike } from \"@azure/core-util\";\nimport { isNodeReadableStream } from \"./typeGuards.js\";\nconst unimplementedMethods = {\n  arrayBuffer: () => {\n    throw new Error(\"Not implemented\");\n  },\n  slice: () => {\n    throw new Error(\"Not implemented\");\n  },\n  text: () => {\n    throw new Error(\"Not implemented\");\n  }\n};\n/**\n * Private symbol used as key on objects created using createFile containing the\n * original source of the file object.\n *\n * This is used in Node to access the original Node stream without using Blob#stream, which\n * returns a web stream. This is done to avoid a couple of bugs to do with Blob#stream and\n * Readable#to/fromWeb in Node versions we support:\n * - https://github.com/nodejs/node/issues/42694 (fixed in Node 18.14)\n * - https://github.com/nodejs/node/issues/48916 (fixed in Node 20.6)\n *\n * Once these versions are no longer supported, we may be able to stop doing this.\n *\n * @internal\n */\nconst rawContent = Symbol(\"rawContent\");\nfunction hasRawContent(x) {\n  return typeof x[rawContent] === \"function\";\n}\n/**\n * Extract the raw content from a given blob-like object. If the input was created using createFile\n * or createFileFromStream, the exact content passed into createFile/createFileFromStream will be used.\n * For true instances of Blob and File, returns the blob's content as a Web ReadableStream<Uint8Array>.\n *\n * @internal\n */\nexport function getRawContent(blob) {\n  if (hasRawContent(blob)) {\n    return blob[rawContent]();\n  } else {\n    return blob.stream();\n  }\n}\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function to:\n * - Create a File object for use in RequestBodyType.formData in environments where the\n *   global File object is unavailable.\n * - Create a File-like object from a readable stream without reading the stream into memory.\n *\n * @param stream - the content of the file as a callback returning a stream. When a File object made using createFile is\n *                  passed in a request's form data map, the stream will not be read into memory\n *                  and instead will be streamed when the request is made. In the event of a retry, the\n *                  stream needs to be read again, so this callback SHOULD return a fresh stream if possible.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFileFromStream(stream, name, options = {}) {\n  var _a, _b, _c, _d;\n  return Object.assign(Object.assign({}, unimplementedMethods), {\n    type: (_a = options.type) !== null && _a !== void 0 ? _a : \"\",\n    lastModified: (_b = options.lastModified) !== null && _b !== void 0 ? _b : new Date().getTime(),\n    webkitRelativePath: (_c = options.webkitRelativePath) !== null && _c !== void 0 ? _c : \"\",\n    size: (_d = options.size) !== null && _d !== void 0 ? _d : -1,\n    name,\n    stream: () => {\n      const s = stream();\n      if (isNodeReadableStream(s)) {\n        throw new Error(\"Not supported: a Node stream was provided as input to createFileFromStream.\");\n      }\n      return s;\n    },\n    [rawContent]: stream\n  });\n}\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function create a File object for use in RequestBodyType.formData in environments where the global File object is unavailable.\n *\n * @param content - the content of the file as a Uint8Array in memory.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFile(content, name, options = {}) {\n  var _a, _b, _c;\n  if (isNodeLike) {\n    return Object.assign(Object.assign({}, unimplementedMethods), {\n      type: (_a = options.type) !== null && _a !== void 0 ? _a : \"\",\n      lastModified: (_b = options.lastModified) !== null && _b !== void 0 ? _b : new Date().getTime(),\n      webkitRelativePath: (_c = options.webkitRelativePath) !== null && _c !== void 0 ? _c : \"\",\n      size: content.byteLength,\n      name,\n      arrayBuffer: async () => content.buffer,\n      stream: () => new Blob([content]).stream(),\n      [rawContent]: () => content\n    });\n  } else {\n    return new File([content], name, options);\n  }\n}","map":{"version":3,"names":["isNodeLike","isNodeReadableStream","unimplementedMethods","arrayBuffer","Error","slice","text","rawContent","Symbol","hasRawContent","x","getRawContent","blob","stream","createFileFromStream","name","options","Object","assign","type","_a","lastModified","_b","Date","getTime","webkitRelativePath","_c","size","_d","s","createFile","content","byteLength","buffer","Blob","File"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\@azure\\core-rest-pipeline\\src\\util\\file.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { isNodeLike } from \"@azure/core-util\";\nimport { isNodeReadableStream } from \"./typeGuards.js\";\n\n/**\n * Options passed into createFile specifying metadata about the file.\n */\nexport interface CreateFileOptions {\n  /**\n   * The MIME type of the file.\n   */\n  type?: string;\n\n  /**\n   * Last modified time of the file as a UNIX timestamp.\n   * This will default to the current date.\n   */\n  lastModified?: number;\n\n  /**\n   * relative path of this file when uploading a directory.\n   */\n  webkitRelativePath?: string;\n}\n\n/**\n * Extra options for createFile when a stream is being passed in.\n */\nexport interface CreateFileFromStreamOptions extends CreateFileOptions {\n  /**\n   * Size of the file represented by the stream in bytes.\n   *\n   * This will be used by the pipeline when calculating the Content-Length header\n   * for the overall request.\n   */\n  size?: number;\n}\n\nconst unimplementedMethods = {\n  arrayBuffer: () => {\n    throw new Error(\"Not implemented\");\n  },\n  slice: () => {\n    throw new Error(\"Not implemented\");\n  },\n  text: () => {\n    throw new Error(\"Not implemented\");\n  },\n};\n\n/**\n * Private symbol used as key on objects created using createFile containing the\n * original source of the file object.\n *\n * This is used in Node to access the original Node stream without using Blob#stream, which\n * returns a web stream. This is done to avoid a couple of bugs to do with Blob#stream and\n * Readable#to/fromWeb in Node versions we support:\n * - https://github.com/nodejs/node/issues/42694 (fixed in Node 18.14)\n * - https://github.com/nodejs/node/issues/48916 (fixed in Node 20.6)\n *\n * Once these versions are no longer supported, we may be able to stop doing this.\n *\n * @internal\n */\nconst rawContent: unique symbol = Symbol(\"rawContent\");\n\n/**\n * Type signature of a blob-like object with a raw content property.\n */\ninterface RawContent {\n  [rawContent](): Uint8Array | NodeJS.ReadableStream | ReadableStream<Uint8Array>;\n}\n\nfunction hasRawContent(x: unknown): x is RawContent {\n  return typeof (x as RawContent)[rawContent] === \"function\";\n}\n\n/**\n * Extract the raw content from a given blob-like object. If the input was created using createFile\n * or createFileFromStream, the exact content passed into createFile/createFileFromStream will be used.\n * For true instances of Blob and File, returns the blob's content as a Web ReadableStream<Uint8Array>.\n *\n * @internal\n */\nexport function getRawContent(\n  blob: Blob,\n): NodeJS.ReadableStream | ReadableStream<Uint8Array> | Uint8Array {\n  if (hasRawContent(blob)) {\n    return blob[rawContent]();\n  } else {\n    return blob.stream();\n  }\n}\n\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function to:\n * - Create a File object for use in RequestBodyType.formData in environments where the\n *   global File object is unavailable.\n * - Create a File-like object from a readable stream without reading the stream into memory.\n *\n * @param stream - the content of the file as a callback returning a stream. When a File object made using createFile is\n *                  passed in a request's form data map, the stream will not be read into memory\n *                  and instead will be streamed when the request is made. In the event of a retry, the\n *                  stream needs to be read again, so this callback SHOULD return a fresh stream if possible.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFileFromStream(\n  stream: () => ReadableStream<Uint8Array> | NodeJS.ReadableStream,\n  name: string,\n  options: CreateFileFromStreamOptions = {},\n): File {\n  return {\n    ...unimplementedMethods,\n    type: options.type ?? \"\",\n    lastModified: options.lastModified ?? new Date().getTime(),\n    webkitRelativePath: options.webkitRelativePath ?? \"\",\n    size: options.size ?? -1,\n    name,\n    stream: () => {\n      const s = stream();\n      if (isNodeReadableStream(s)) {\n        throw new Error(\n          \"Not supported: a Node stream was provided as input to createFileFromStream.\",\n        );\n      }\n\n      return s;\n    },\n    [rawContent]: stream,\n  } as File & RawContent;\n}\n\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function create a File object for use in RequestBodyType.formData in environments where the global File object is unavailable.\n *\n * @param content - the content of the file as a Uint8Array in memory.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFile(\n  content: Uint8Array,\n  name: string,\n  options: CreateFileOptions = {},\n): File {\n  if (isNodeLike) {\n    return {\n      ...unimplementedMethods,\n      type: options.type ?? \"\",\n      lastModified: options.lastModified ?? new Date().getTime(),\n      webkitRelativePath: options.webkitRelativePath ?? \"\",\n      size: content.byteLength,\n      name,\n      arrayBuffer: async () => content.buffer,\n      stream: () => new Blob([content]).stream(),\n      [rawContent]: () => content,\n    } as File & RawContent;\n  } else {\n    return new File([content], name, options);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}