{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { ServiceClient } from \"@azure/core-client\";\nimport { isNode } from \"@azure/core-util\";\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { AuthenticationError, AuthenticationErrorName } from \"../errors\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { DefaultAuthorityHost, SDK_VERSION } from \"../constants\";\nimport { tracingClient } from \"../util/tracing\";\nimport { logger } from \"../util/logging\";\nimport { parseExpirationTimestamp, parseRefreshTimestamp } from \"../credentials/managedIdentityCredential/utils\";\nconst noCorrelationId = \"noCorrelationId\";\n/**\n * @internal\n */\nexport function getIdentityClientAuthorityHost(options) {\n  // The authorityHost can come from options or from the AZURE_AUTHORITY_HOST environment variable.\n  let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost;\n  // The AZURE_AUTHORITY_HOST environment variable can only be provided in Node.js.\n  if (isNode) {\n    authorityHost = authorityHost !== null && authorityHost !== void 0 ? authorityHost : process.env.AZURE_AUTHORITY_HOST;\n  }\n  // If the authorityHost is not provided, we use the default one from the public cloud: https://login.microsoftonline.com\n  return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;\n}\n/**\n * The network module used by the Identity credentials.\n *\n * It allows for credentials to abort any pending request independently of the MSAL flow,\n * by calling to the `abortRequests()` method.\n *\n */\nexport class IdentityClient extends ServiceClient {\n  constructor(options) {\n    var _a, _b;\n    const packageDetails = `azsdk-js-identity/${SDK_VERSION}`;\n    const userAgentPrefix = ((_a = options === null || options === void 0 ? void 0 : options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix) ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;\n    const baseUri = getIdentityClientAuthorityHost(options);\n    if (!baseUri.startsWith(\"https:\")) {\n      throw new Error(\"The authorityHost address must use the 'https' protocol.\");\n    }\n    super(Object.assign(Object.assign({\n      requestContentType: \"application/json; charset=utf-8\",\n      retryOptions: {\n        maxRetries: 3\n      }\n    }, options), {\n      userAgentOptions: {\n        userAgentPrefix\n      },\n      baseUri\n    }));\n    this.allowInsecureConnection = false;\n    this.authorityHost = baseUri;\n    this.abortControllers = new Map();\n    this.allowLoggingAccountIdentifiers = (_b = options === null || options === void 0 ? void 0 : options.loggingOptions) === null || _b === void 0 ? void 0 : _b.allowLoggingAccountIdentifiers;\n    // used for WorkloadIdentity\n    this.tokenCredentialOptions = Object.assign({}, options);\n    // used for ManagedIdentity\n    if (options === null || options === void 0 ? void 0 : options.allowInsecureConnection) {\n      this.allowInsecureConnection = options.allowInsecureConnection;\n    }\n  }\n  async sendTokenRequest(request) {\n    logger.info(`IdentityClient: sending token request to [${request.url}]`);\n    const response = await this.sendRequest(request);\n    if (response.bodyAsText && (response.status === 200 || response.status === 201)) {\n      const parsedBody = JSON.parse(response.bodyAsText);\n      if (!parsedBody.access_token) {\n        return null;\n      }\n      this.logIdentifiers(response);\n      const token = {\n        accessToken: {\n          token: parsedBody.access_token,\n          expiresOnTimestamp: parseExpirationTimestamp(parsedBody),\n          refreshAfterTimestamp: parseRefreshTimestamp(parsedBody),\n          tokenType: \"Bearer\"\n        },\n        refreshToken: parsedBody.refresh_token\n      };\n      logger.info(`IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);\n      return token;\n    } else {\n      const error = new AuthenticationError(response.status, response.bodyAsText);\n      logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);\n      throw error;\n    }\n  }\n  async refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, options = {}) {\n    if (refreshToken === undefined) {\n      return null;\n    }\n    logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);\n    const refreshParams = {\n      grant_type: \"refresh_token\",\n      client_id: clientId,\n      refresh_token: refreshToken,\n      scope: scopes\n    };\n    if (clientSecret !== undefined) {\n      refreshParams.client_secret = clientSecret;\n    }\n    const query = new URLSearchParams(refreshParams);\n    return tracingClient.withSpan(\"IdentityClient.refreshAccessToken\", options, async updatedOptions => {\n      try {\n        const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);\n        const request = createPipelineRequest({\n          url: `${this.authorityHost}/${tenantId}/${urlSuffix}`,\n          method: \"POST\",\n          body: query.toString(),\n          abortSignal: options.abortSignal,\n          headers: createHttpHeaders({\n            Accept: \"application/json\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n          }),\n          tracingOptions: updatedOptions.tracingOptions\n        });\n        const response = await this.sendTokenRequest(request);\n        logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);\n        return response;\n      } catch (err) {\n        if (err.name === AuthenticationErrorName && err.errorResponse.error === \"interaction_required\") {\n          // It's likely that the refresh token has expired, so\n          // return null so that the credential implementation will\n          // initiate the authentication flow again.\n          logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);\n          return null;\n        } else {\n          logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);\n          throw err;\n        }\n      }\n    });\n  }\n  // Here is a custom layer that allows us to abort requests that go through MSAL,\n  // since MSAL doesn't allow us to pass options all the way through.\n  generateAbortSignal(correlationId) {\n    const controller = new AbortController();\n    const controllers = this.abortControllers.get(correlationId) || [];\n    controllers.push(controller);\n    this.abortControllers.set(correlationId, controllers);\n    const existingOnAbort = controller.signal.onabort;\n    controller.signal.onabort = (...params) => {\n      this.abortControllers.set(correlationId, undefined);\n      if (existingOnAbort) {\n        existingOnAbort.apply(controller.signal, params);\n      }\n    };\n    return controller.signal;\n  }\n  abortRequests(correlationId) {\n    const key = correlationId || noCorrelationId;\n    const controllers = [...(this.abortControllers.get(key) || []),\n    // MSAL passes no correlation ID to the get requests...\n    ...(this.abortControllers.get(noCorrelationId) || [])];\n    if (!controllers.length) {\n      return;\n    }\n    for (const controller of controllers) {\n      controller.abort();\n    }\n    this.abortControllers.set(key, undefined);\n  }\n  getCorrelationId(options) {\n    var _a;\n    const parameter = (_a = options === null || options === void 0 ? void 0 : options.body) === null || _a === void 0 ? void 0 : _a.split(\"&\").map(part => part.split(\"=\")).find(([key]) => key === \"client-request-id\");\n    return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;\n  }\n  // The MSAL network module methods follow\n  async sendGetRequestAsync(url, options) {\n    const request = createPipelineRequest({\n      url,\n      method: \"GET\",\n      body: options === null || options === void 0 ? void 0 : options.body,\n      allowInsecureConnection: this.allowInsecureConnection,\n      headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n      abortSignal: this.generateAbortSignal(noCorrelationId)\n    });\n    const response = await this.sendRequest(request);\n    this.logIdentifiers(response);\n    return {\n      body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n      headers: response.headers.toJSON(),\n      status: response.status\n    };\n  }\n  async sendPostRequestAsync(url, options) {\n    const request = createPipelineRequest({\n      url,\n      method: \"POST\",\n      body: options === null || options === void 0 ? void 0 : options.body,\n      headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n      allowInsecureConnection: this.allowInsecureConnection,\n      // MSAL doesn't send the correlation ID on the get requests.\n      abortSignal: this.generateAbortSignal(this.getCorrelationId(options))\n    });\n    const response = await this.sendRequest(request);\n    this.logIdentifiers(response);\n    return {\n      body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n      headers: response.headers.toJSON(),\n      status: response.status\n    };\n  }\n  /**\n   *\n   * @internal\n   */\n  getTokenCredentialOptions() {\n    return this.tokenCredentialOptions;\n  }\n  /**\n   * If allowLoggingAccountIdentifiers was set on the constructor options\n   * we try to log the account identifiers by parsing the received access token.\n   *\n   * The account identifiers we try to log are:\n   * - `appid`: The application or Client Identifier.\n   * - `upn`: User Principal Name.\n   *   - It might not be available in some authentication scenarios.\n   *   - If it's not available, we put a placeholder: \"No User Principal Name available\".\n   * - `tid`: Tenant Identifier.\n   * - `oid`: Object Identifier of the authenticated user.\n   */\n  logIdentifiers(response) {\n    if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {\n      return;\n    }\n    const unavailableUpn = \"No User Principal Name available\";\n    try {\n      const parsed = response.parsedBody || JSON.parse(response.bodyAsText);\n      const accessToken = parsed.access_token;\n      if (!accessToken) {\n        // Without an access token allowLoggingAccountIdentifiers isn't useful.\n        return;\n      }\n      const base64Metadata = accessToken.split(\".\")[1];\n      const {\n        appid,\n        upn,\n        tid,\n        oid\n      } = JSON.parse(Buffer.from(base64Metadata, \"base64\").toString(\"utf8\"));\n      logger.info(`[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${upn || unavailableUpn}. Object ID (user): ${oid}`);\n    } catch (e) {\n      logger.warning(\"allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:\", e.message);\n    }\n  }\n}","map":{"version":3,"names":["ServiceClient","isNode","createHttpHeaders","createPipelineRequest","AuthenticationError","AuthenticationErrorName","getIdentityTokenEndpointSuffix","DefaultAuthorityHost","SDK_VERSION","tracingClient","logger","parseExpirationTimestamp","parseRefreshTimestamp","noCorrelationId","getIdentityClientAuthorityHost","options","authorityHost","process","env","AZURE_AUTHORITY_HOST","IdentityClient","constructor","packageDetails","userAgentPrefix","_a","userAgentOptions","baseUri","startsWith","Error","Object","assign","requestContentType","retryOptions","maxRetries","allowInsecureConnection","abortControllers","Map","allowLoggingAccountIdentifiers","_b","loggingOptions","tokenCredentialOptions","sendTokenRequest","request","info","url","response","sendRequest","bodyAsText","status","parsedBody","JSON","parse","access_token","logIdentifiers","token","accessToken","expiresOnTimestamp","refreshAfterTimestamp","tokenType","refreshToken","refresh_token","error","warning","errorResponse","errorDescription","refreshAccessToken","tenantId","clientId","scopes","clientSecret","undefined","refreshParams","grant_type","client_id","scope","client_secret","query","URLSearchParams","withSpan","updatedOptions","urlSuffix","method","body","toString","abortSignal","headers","Accept","tracingOptions","err","name","generateAbortSignal","correlationId","controller","AbortController","controllers","get","push","set","existingOnAbort","signal","onabort","params","apply","abortRequests","key","length","abort","getCorrelationId","parameter","split","map","part","find","sendGetRequestAsync","toJSON","sendPostRequestAsync","getTokenCredentialOptions","unavailableUpn","parsed","base64Metadata","appid","upn","tid","oid","Buffer","from","e","message"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\@azure\\identity\\src\\client\\identityClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { INetworkModule, NetworkRequestOptions, NetworkResponse } from \"@azure/msal-node\";\nimport { AccessToken, GetTokenOptions } from \"@azure/core-auth\";\nimport { ServiceClient } from \"@azure/core-client\";\nimport { isNode } from \"@azure/core-util\";\nimport {\n  PipelineRequest,\n  PipelineResponse,\n  createHttpHeaders,\n  createPipelineRequest,\n} from \"@azure/core-rest-pipeline\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { AuthenticationError, AuthenticationErrorName } from \"../errors\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { DefaultAuthorityHost, SDK_VERSION } from \"../constants\";\nimport { tracingClient } from \"../util/tracing\";\nimport { logger } from \"../util/logging\";\nimport { TokenCredentialOptions } from \"../tokenCredentialOptions\";\nimport {\n  TokenResponseParsedBody,\n  parseExpirationTimestamp,\n  parseRefreshTimestamp,\n} from \"../credentials/managedIdentityCredential/utils\";\n\nconst noCorrelationId = \"noCorrelationId\";\n\n/**\n * An internal type used to communicate details of a token request's\n * response that should not be sent back as part of the access token.\n */\nexport interface TokenResponse {\n  /**\n   * The AccessToken to be returned from getToken.\n   */\n  accessToken: AccessToken;\n  /**\n   * The refresh token if the 'offline_access' scope was used.\n   */\n  refreshToken?: string;\n}\n\n/**\n * @internal\n */\nexport function getIdentityClientAuthorityHost(options?: TokenCredentialOptions): string {\n  // The authorityHost can come from options or from the AZURE_AUTHORITY_HOST environment variable.\n  let authorityHost = options?.authorityHost;\n\n  // The AZURE_AUTHORITY_HOST environment variable can only be provided in Node.js.\n  if (isNode) {\n    authorityHost = authorityHost ?? process.env.AZURE_AUTHORITY_HOST;\n  }\n\n  // If the authorityHost is not provided, we use the default one from the public cloud: https://login.microsoftonline.com\n  return authorityHost ?? DefaultAuthorityHost;\n}\n\n/**\n * The network module used by the Identity credentials.\n *\n * It allows for credentials to abort any pending request independently of the MSAL flow,\n * by calling to the `abortRequests()` method.\n *\n */\nexport class IdentityClient extends ServiceClient implements INetworkModule {\n  public authorityHost: string;\n  private allowLoggingAccountIdentifiers?: boolean;\n  private abortControllers: Map<string, AbortController[] | undefined>;\n  private allowInsecureConnection: boolean = false;\n  // used for WorkloadIdentity\n  private tokenCredentialOptions: TokenCredentialOptions;\n\n  constructor(options?: TokenCredentialOptions) {\n    const packageDetails = `azsdk-js-identity/${SDK_VERSION}`;\n    const userAgentPrefix = options?.userAgentOptions?.userAgentPrefix\n      ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`\n      : `${packageDetails}`;\n\n    const baseUri = getIdentityClientAuthorityHost(options);\n    if (!baseUri.startsWith(\"https:\")) {\n      throw new Error(\"The authorityHost address must use the 'https' protocol.\");\n    }\n\n    super({\n      requestContentType: \"application/json; charset=utf-8\",\n      retryOptions: {\n        maxRetries: 3,\n      },\n      ...options,\n      userAgentOptions: {\n        userAgentPrefix,\n      },\n      baseUri,\n    });\n\n    this.authorityHost = baseUri;\n    this.abortControllers = new Map();\n    this.allowLoggingAccountIdentifiers = options?.loggingOptions?.allowLoggingAccountIdentifiers;\n    // used for WorkloadIdentity\n    this.tokenCredentialOptions = { ...options };\n\n    // used for ManagedIdentity\n    if (options?.allowInsecureConnection) {\n      this.allowInsecureConnection = options.allowInsecureConnection;\n    }\n  }\n\n  async sendTokenRequest(request: PipelineRequest): Promise<TokenResponse | null> {\n    logger.info(`IdentityClient: sending token request to [${request.url}]`);\n    const response = await this.sendRequest(request);\n    if (response.bodyAsText && (response.status === 200 || response.status === 201)) {\n      const parsedBody: TokenResponseParsedBody = JSON.parse(response.bodyAsText);\n\n      if (!parsedBody.access_token) {\n        return null;\n      }\n\n      this.logIdentifiers(response);\n\n      const token = {\n        accessToken: {\n          token: parsedBody.access_token,\n          expiresOnTimestamp: parseExpirationTimestamp(parsedBody),\n          refreshAfterTimestamp: parseRefreshTimestamp(parsedBody),\n          tokenType: \"Bearer\",\n        } as AccessToken,\n        refreshToken: parsedBody.refresh_token,\n      };\n\n      logger.info(\n        `IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`,\n      );\n      return token;\n    } else {\n      const error = new AuthenticationError(response.status, response.bodyAsText);\n      logger.warning(\n        `IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`,\n      );\n      throw error;\n    }\n  }\n\n  async refreshAccessToken(\n    tenantId: string,\n    clientId: string,\n    scopes: string,\n    refreshToken: string | undefined,\n    clientSecret: string | undefined,\n    options: GetTokenOptions = {},\n  ): Promise<TokenResponse | null> {\n    if (refreshToken === undefined) {\n      return null;\n    }\n    logger.info(\n      `IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`,\n    );\n\n    const refreshParams = {\n      grant_type: \"refresh_token\",\n      client_id: clientId,\n      refresh_token: refreshToken,\n      scope: scopes,\n    };\n\n    if (clientSecret !== undefined) {\n      (refreshParams as any).client_secret = clientSecret;\n    }\n\n    const query = new URLSearchParams(refreshParams);\n\n    return tracingClient.withSpan(\n      \"IdentityClient.refreshAccessToken\",\n      options,\n      async (updatedOptions) => {\n        try {\n          const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);\n          const request = createPipelineRequest({\n            url: `${this.authorityHost}/${tenantId}/${urlSuffix}`,\n            method: \"POST\",\n            body: query.toString(),\n            abortSignal: options.abortSignal,\n            headers: createHttpHeaders({\n              Accept: \"application/json\",\n              \"Content-Type\": \"application/x-www-form-urlencoded\",\n            }),\n            tracingOptions: updatedOptions.tracingOptions,\n          });\n\n          const response = await this.sendTokenRequest(request);\n          logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);\n          return response;\n        } catch (err: any) {\n          if (\n            err.name === AuthenticationErrorName &&\n            err.errorResponse.error === \"interaction_required\"\n          ) {\n            // It's likely that the refresh token has expired, so\n            // return null so that the credential implementation will\n            // initiate the authentication flow again.\n            logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);\n            return null;\n          } else {\n            logger.warning(\n              `IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`,\n            );\n            throw err;\n          }\n        }\n      },\n    );\n  }\n\n  // Here is a custom layer that allows us to abort requests that go through MSAL,\n  // since MSAL doesn't allow us to pass options all the way through.\n\n  generateAbortSignal(correlationId: string): AbortSignalLike {\n    const controller = new AbortController();\n    const controllers = this.abortControllers.get(correlationId) || [];\n    controllers.push(controller);\n    this.abortControllers.set(correlationId, controllers);\n    const existingOnAbort = controller.signal.onabort;\n    controller.signal.onabort = (...params) => {\n      this.abortControllers.set(correlationId, undefined);\n      if (existingOnAbort) {\n        existingOnAbort.apply(controller.signal, params);\n      }\n    };\n    return controller.signal;\n  }\n\n  abortRequests(correlationId?: string): void {\n    const key = correlationId || noCorrelationId;\n    const controllers = [\n      ...(this.abortControllers.get(key) || []),\n      // MSAL passes no correlation ID to the get requests...\n      ...(this.abortControllers.get(noCorrelationId) || []),\n    ];\n    if (!controllers.length) {\n      return;\n    }\n    for (const controller of controllers) {\n      controller.abort();\n    }\n    this.abortControllers.set(key, undefined);\n  }\n\n  getCorrelationId(options?: NetworkRequestOptions): string {\n    const parameter = options?.body\n      ?.split(\"&\")\n      .map((part) => part.split(\"=\"))\n      .find(([key]) => key === \"client-request-id\");\n    return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;\n  }\n\n  // The MSAL network module methods follow\n\n  async sendGetRequestAsync<T>(\n    url: string,\n    options?: NetworkRequestOptions,\n  ): Promise<NetworkResponse<T>> {\n    const request = createPipelineRequest({\n      url,\n      method: \"GET\",\n      body: options?.body,\n      allowInsecureConnection: this.allowInsecureConnection,\n      headers: createHttpHeaders(options?.headers),\n      abortSignal: this.generateAbortSignal(noCorrelationId),\n    });\n\n    const response = await this.sendRequest(request);\n\n    this.logIdentifiers(response);\n\n    return {\n      body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n      headers: response.headers.toJSON(),\n      status: response.status,\n    };\n  }\n\n  async sendPostRequestAsync<T>(\n    url: string,\n    options?: NetworkRequestOptions,\n  ): Promise<NetworkResponse<T>> {\n    const request = createPipelineRequest({\n      url,\n      method: \"POST\",\n      body: options?.body,\n      headers: createHttpHeaders(options?.headers),\n      allowInsecureConnection: this.allowInsecureConnection,\n      // MSAL doesn't send the correlation ID on the get requests.\n      abortSignal: this.generateAbortSignal(this.getCorrelationId(options)),\n    });\n\n    const response = await this.sendRequest(request);\n\n    this.logIdentifiers(response);\n\n    return {\n      body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n      headers: response.headers.toJSON(),\n      status: response.status,\n    };\n  }\n\n  /**\n   *\n   * @internal\n   */\n  getTokenCredentialOptions(): TokenCredentialOptions {\n    return this.tokenCredentialOptions;\n  }\n  /**\n   * If allowLoggingAccountIdentifiers was set on the constructor options\n   * we try to log the account identifiers by parsing the received access token.\n   *\n   * The account identifiers we try to log are:\n   * - `appid`: The application or Client Identifier.\n   * - `upn`: User Principal Name.\n   *   - It might not be available in some authentication scenarios.\n   *   - If it's not available, we put a placeholder: \"No User Principal Name available\".\n   * - `tid`: Tenant Identifier.\n   * - `oid`: Object Identifier of the authenticated user.\n   */\n  private logIdentifiers(response: PipelineResponse): void {\n    if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {\n      return;\n    }\n    const unavailableUpn = \"No User Principal Name available\";\n    try {\n      const parsed = (response as any).parsedBody || JSON.parse(response.bodyAsText);\n      const accessToken = parsed.access_token;\n      if (!accessToken) {\n        // Without an access token allowLoggingAccountIdentifiers isn't useful.\n        return;\n      }\n      const base64Metadata = accessToken.split(\".\")[1];\n      const { appid, upn, tid, oid } = JSON.parse(\n        Buffer.from(base64Metadata, \"base64\").toString(\"utf8\"),\n      );\n\n      logger.info(\n        `[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${\n          upn || unavailableUpn\n        }. Object ID (user): ${oid}`,\n      );\n    } catch (e: any) {\n      logger.warning(\n        \"allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:\",\n        e.message,\n      );\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}