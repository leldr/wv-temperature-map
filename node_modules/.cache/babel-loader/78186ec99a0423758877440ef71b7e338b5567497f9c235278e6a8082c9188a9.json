{"ast":null,"code":"/*! @azure/msal-browser v3.27.0 2024-11-05 */\n'use strict';\n\nimport { PerformanceClient, Constants, Logger } from '@azure/msal-common/browser';\nimport { name, version } from '../packageMetadata.mjs';\nimport { BrowserCacheLocation, BROWSER_PERF_ENABLED_KEY } from '../utils/BrowserConstants.mjs';\nimport { createNewGuid } from '../crypto/BrowserCrypto.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Returns browser performance measurement module if session flag is enabled. Returns undefined otherwise.\r\n */\nfunction getPerfMeasurementModule() {\n  let sessionStorage;\n  try {\n    var _sessionStorage;\n    sessionStorage = window[BrowserCacheLocation.SessionStorage];\n    const perfEnabled = (_sessionStorage = sessionStorage) === null || _sessionStorage === void 0 ? void 0 : _sessionStorage.getItem(BROWSER_PERF_ENABLED_KEY);\n    if (Number(perfEnabled) === 1) {\n      return import('./BrowserPerformanceMeasurement.mjs');\n    }\n    // Mute errors if it's a non-browser environment or cookies are blocked.\n  } catch (e) {}\n  return undefined;\n}\n/**\r\n * Returns boolean, indicating whether browser supports window.performance.now() function.\r\n */\nfunction supportsBrowserPerformanceNow() {\n  return typeof window !== \"undefined\" && typeof window.performance !== \"undefined\" && typeof window.performance.now === \"function\";\n}\n/**\r\n * Returns event duration in milliseconds using window performance API if available. Returns undefined otherwise.\r\n * @param startTime {DOMHighResTimeStamp | undefined}\r\n * @returns {number | undefined}\r\n */\nfunction getPerfDurationMs(startTime) {\n  if (!startTime || !supportsBrowserPerformanceNow()) {\n    return undefined;\n  }\n  return Math.round(window.performance.now() - startTime);\n}\nclass BrowserPerformanceClient extends PerformanceClient {\n  constructor(configuration, intFields, abbreviations) {\n    var _configuration$system, _configuration$teleme;\n    super(configuration.auth.clientId, configuration.auth.authority || `${Constants.DEFAULT_AUTHORITY}`, new Logger(((_configuration$system = configuration.system) === null || _configuration$system === void 0 ? void 0 : _configuration$system.loggerOptions) || {}, name, version), name, version, ((_configuration$teleme = configuration.telemetry) === null || _configuration$teleme === void 0 ? void 0 : _configuration$teleme.application) || {\n      appName: \"\",\n      appVersion: \"\"\n    }, intFields, abbreviations);\n  }\n  generateId() {\n    return createNewGuid();\n  }\n  getPageVisibility() {\n    var _document$visibilityS;\n    return ((_document$visibilityS = document.visibilityState) === null || _document$visibilityS === void 0 ? void 0 : _document$visibilityS.toString()) || null;\n  }\n  deleteIncompleteSubMeasurements(inProgressEvent) {\n    var _getPerfMeasurementMo;\n    void ((_getPerfMeasurementMo = getPerfMeasurementModule()) === null || _getPerfMeasurementMo === void 0 ? void 0 : _getPerfMeasurementMo.then(module => {\n      const rootEvent = this.eventsByCorrelationId.get(inProgressEvent.event.correlationId);\n      const isRootEvent = rootEvent && rootEvent.eventId === inProgressEvent.event.eventId;\n      const incompleteMeasurements = [];\n      if (isRootEvent && rootEvent !== null && rootEvent !== void 0 && rootEvent.incompleteSubMeasurements) {\n        rootEvent.incompleteSubMeasurements.forEach(subMeasurement => {\n          incompleteMeasurements.push({\n            ...subMeasurement\n          });\n        });\n      }\n      // Clean up remaining marks for incomplete sub-measurements\n      module.BrowserPerformanceMeasurement.flushMeasurements(inProgressEvent.event.correlationId, incompleteMeasurements);\n    }));\n  }\n  /**\r\n   * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\r\n   * Also captures browser page visibilityState.\r\n   *\r\n   * @param {PerformanceEvents} measureName\r\n   * @param {?string} [correlationId]\r\n   * @returns {((event?: Partial<PerformanceEvent>) => PerformanceEvent| null)}\r\n   */\n  startMeasurement(measureName, correlationId) {\n    var _getPerfMeasurementMo2;\n    // Capture page visibilityState and then invoke start/end measurement\n    const startPageVisibility = this.getPageVisibility();\n    const inProgressEvent = super.startMeasurement(measureName, correlationId);\n    const startTime = supportsBrowserPerformanceNow() ? window.performance.now() : undefined;\n    const browserMeasurement = (_getPerfMeasurementMo2 = getPerfMeasurementModule()) === null || _getPerfMeasurementMo2 === void 0 ? void 0 : _getPerfMeasurementMo2.then(module => {\n      return new module.BrowserPerformanceMeasurement(measureName, inProgressEvent.event.correlationId);\n    });\n    void (browserMeasurement === null || browserMeasurement === void 0 ? void 0 : browserMeasurement.then(measurement => measurement.startMeasurement()));\n    return {\n      ...inProgressEvent,\n      end: (event, error) => {\n        const res = inProgressEvent.end({\n          ...event,\n          startPageVisibility,\n          endPageVisibility: this.getPageVisibility(),\n          durationMs: getPerfDurationMs(startTime)\n        }, error);\n        void (browserMeasurement === null || browserMeasurement === void 0 ? void 0 : browserMeasurement.then(measurement => measurement.endMeasurement()));\n        this.deleteIncompleteSubMeasurements(inProgressEvent);\n        return res;\n      },\n      discard: () => {\n        inProgressEvent.discard();\n        void (browserMeasurement === null || browserMeasurement === void 0 ? void 0 : browserMeasurement.then(measurement => measurement.flushMeasurement()));\n        this.deleteIncompleteSubMeasurements(inProgressEvent);\n      }\n    };\n  }\n  /**\r\n   * Adds pre-queue time to preQueueTimeByCorrelationId map.\r\n   * @param {PerformanceEvents} eventName\r\n   * @param {?string} correlationId\r\n   * @returns\r\n   */\n  setPreQueueTime(eventName, correlationId) {\n    if (!supportsBrowserPerformanceNow()) {\n      this.logger.trace(`BrowserPerformanceClient: window performance API not available, unable to set telemetry queue time for ${eventName}`);\n      return;\n    }\n    if (!correlationId) {\n      this.logger.trace(`BrowserPerformanceClient: correlationId for ${eventName} not provided, unable to set telemetry queue time`);\n      return;\n    }\n    const preQueueEvent = this.preQueueTimeByCorrelationId.get(correlationId);\n    /**\r\n     * Manually complete queue measurement if there is an incomplete pre-queue event.\r\n     * Incomplete pre-queue events are instrumentation bugs that should be fixed.\r\n     */\n    if (preQueueEvent) {\n      this.logger.trace(`BrowserPerformanceClient: Incomplete pre-queue ${preQueueEvent.name} found`, correlationId);\n      this.addQueueMeasurement(preQueueEvent.name, correlationId, undefined, true);\n    }\n    this.preQueueTimeByCorrelationId.set(correlationId, {\n      name: eventName,\n      time: window.performance.now()\n    });\n  }\n  /**\r\n   * Calculates and adds queue time measurement for given performance event.\r\n   *\r\n   * @param {PerformanceEvents} eventName\r\n   * @param {?string} correlationId\r\n   * @param {?number} queueTime\r\n   * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\r\n   * @returns\r\n   */\n  addQueueMeasurement(eventName, correlationId, queueTime, manuallyCompleted) {\n    if (!supportsBrowserPerformanceNow()) {\n      this.logger.trace(`BrowserPerformanceClient: window performance API not available, unable to add queue measurement for ${eventName}`);\n      return;\n    }\n    if (!correlationId) {\n      this.logger.trace(`BrowserPerformanceClient: correlationId for ${eventName} not provided, unable to add queue measurement`);\n      return;\n    }\n    const preQueueTime = super.getPreQueueTime(eventName, correlationId);\n    if (!preQueueTime) {\n      return;\n    }\n    const currentTime = window.performance.now();\n    const resQueueTime = queueTime || super.calculateQueuedTime(preQueueTime, currentTime);\n    return super.addQueueMeasurement(eventName, correlationId, resQueueTime, manuallyCompleted);\n  }\n}\nexport { BrowserPerformanceClient };","map":{"version":3,"names":["getPerfMeasurementModule","sessionStorage","_sessionStorage","window","BrowserCacheLocation","SessionStorage","perfEnabled","getItem","BROWSER_PERF_ENABLED_KEY","Number","e","undefined","supportsBrowserPerformanceNow","performance","now","getPerfDurationMs","startTime","Math","round","BrowserPerformanceClient","PerformanceClient","constructor","configuration","intFields","abbreviations","_configuration$system","_configuration$teleme","auth","clientId","authority","Constants","DEFAULT_AUTHORITY","Logger","system","loggerOptions","name","version","telemetry","application","appName","appVersion","generateId","createNewGuid","getPageVisibility","_document$visibilityS","document","visibilityState","toString","deleteIncompleteSubMeasurements","inProgressEvent","_getPerfMeasurementMo","then","module","rootEvent","eventsByCorrelationId","get","event","correlationId","isRootEvent","eventId","incompleteMeasurements","incompleteSubMeasurements","forEach","subMeasurement","push","BrowserPerformanceMeasurement","flushMeasurements","startMeasurement","measureName","_getPerfMeasurementMo2","startPageVisibility","browserMeasurement","measurement","end","error","res","endPageVisibility","durationMs","endMeasurement","discard","flushMeasurement","setPreQueueTime","eventName","logger","trace","preQueueEvent","preQueueTimeByCorrelationId","addQueueMeasurement","set","time","queueTime","manuallyCompleted","preQueueTime","getPreQueueTime","currentTime","resQueueTime","calculateQueuedTime"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\@azure\\msal-browser\\src\\telemetry\\BrowserPerformanceClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    Constants,\n    InProgressPerformanceEvent,\n    IPerformanceClient,\n    Logger,\n    PerformanceClient,\n    PerformanceEvent,\n    PerformanceEvents,\n    PreQueueEvent,\n    SubMeasurement,\n} from \"@azure/msal-common/browser\";\nimport { Configuration } from \"../config/Configuration.js\";\nimport { name, version } from \"../packageMetadata.js\";\nimport {\n    BROWSER_PERF_ENABLED_KEY,\n    BrowserCacheLocation,\n} from \"../utils/BrowserConstants.js\";\nimport * as BrowserCrypto from \"../crypto/BrowserCrypto.js\";\n\n/**\n * Returns browser performance measurement module if session flag is enabled. Returns undefined otherwise.\n */\nfunction getPerfMeasurementModule() {\n    let sessionStorage: Storage | undefined;\n    try {\n        sessionStorage = window[BrowserCacheLocation.SessionStorage];\n        const perfEnabled = sessionStorage?.getItem(BROWSER_PERF_ENABLED_KEY);\n        if (Number(perfEnabled) === 1) {\n            return import(\"./BrowserPerformanceMeasurement.js\");\n        }\n        // Mute errors if it's a non-browser environment or cookies are blocked.\n    } catch (e) {}\n\n    return undefined;\n}\n\n/**\n * Returns boolean, indicating whether browser supports window.performance.now() function.\n */\nfunction supportsBrowserPerformanceNow(): boolean {\n    return (\n        typeof window !== \"undefined\" &&\n        typeof window.performance !== \"undefined\" &&\n        typeof window.performance.now === \"function\"\n    );\n}\n\n/**\n * Returns event duration in milliseconds using window performance API if available. Returns undefined otherwise.\n * @param startTime {DOMHighResTimeStamp | undefined}\n * @returns {number | undefined}\n */\nfunction getPerfDurationMs(\n    startTime: DOMHighResTimeStamp | undefined\n): number | undefined {\n    if (!startTime || !supportsBrowserPerformanceNow()) {\n        return undefined;\n    }\n\n    return Math.round(window.performance.now() - startTime);\n}\n\nexport class BrowserPerformanceClient\n    extends PerformanceClient\n    implements IPerformanceClient\n{\n    constructor(\n        configuration: Configuration,\n        intFields?: Set<string>,\n        abbreviations?: Map<string, string>\n    ) {\n        super(\n            configuration.auth.clientId,\n            configuration.auth.authority || `${Constants.DEFAULT_AUTHORITY}`,\n            new Logger(\n                configuration.system?.loggerOptions || {},\n                name,\n                version\n            ),\n            name,\n            version,\n            configuration.telemetry?.application || {\n                appName: \"\",\n                appVersion: \"\",\n            },\n            intFields,\n            abbreviations\n        );\n    }\n\n    generateId(): string {\n        return BrowserCrypto.createNewGuid();\n    }\n\n    private getPageVisibility(): string | null {\n        return document.visibilityState?.toString() || null;\n    }\n\n    private deleteIncompleteSubMeasurements(\n        inProgressEvent: InProgressPerformanceEvent\n    ): void {\n        void getPerfMeasurementModule()?.then((module) => {\n            const rootEvent = this.eventsByCorrelationId.get(\n                inProgressEvent.event.correlationId\n            );\n            const isRootEvent =\n                rootEvent &&\n                rootEvent.eventId === inProgressEvent.event.eventId;\n            const incompleteMeasurements: SubMeasurement[] = [];\n            if (isRootEvent && rootEvent?.incompleteSubMeasurements) {\n                rootEvent.incompleteSubMeasurements.forEach(\n                    (subMeasurement: SubMeasurement) => {\n                        incompleteMeasurements.push({ ...subMeasurement });\n                    }\n                );\n            }\n            // Clean up remaining marks for incomplete sub-measurements\n            module.BrowserPerformanceMeasurement.flushMeasurements(\n                inProgressEvent.event.correlationId,\n                incompleteMeasurements\n            );\n        });\n    }\n\n    /**\n     * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\n     * Also captures browser page visibilityState.\n     *\n     * @param {PerformanceEvents} measureName\n     * @param {?string} [correlationId]\n     * @returns {((event?: Partial<PerformanceEvent>) => PerformanceEvent| null)}\n     */\n    startMeasurement(\n        measureName: string,\n        correlationId?: string\n    ): InProgressPerformanceEvent {\n        // Capture page visibilityState and then invoke start/end measurement\n        const startPageVisibility = this.getPageVisibility();\n        const inProgressEvent = super.startMeasurement(\n            measureName,\n            correlationId\n        );\n        const startTime: number | undefined = supportsBrowserPerformanceNow()\n            ? window.performance.now()\n            : undefined;\n\n        const browserMeasurement = getPerfMeasurementModule()?.then(\n            (module) => {\n                return new module.BrowserPerformanceMeasurement(\n                    measureName,\n                    inProgressEvent.event.correlationId\n                );\n            }\n        );\n        void browserMeasurement?.then((measurement) =>\n            measurement.startMeasurement()\n        );\n\n        return {\n            ...inProgressEvent,\n            end: (\n                event?: Partial<PerformanceEvent>,\n                error?: unknown\n            ): PerformanceEvent | null => {\n                const res = inProgressEvent.end(\n                    {\n                        ...event,\n                        startPageVisibility,\n                        endPageVisibility: this.getPageVisibility(),\n                        durationMs: getPerfDurationMs(startTime),\n                    },\n                    error\n                );\n                void browserMeasurement?.then((measurement) =>\n                    measurement.endMeasurement()\n                );\n                this.deleteIncompleteSubMeasurements(inProgressEvent);\n\n                return res;\n            },\n            discard: () => {\n                inProgressEvent.discard();\n                void browserMeasurement?.then((measurement) =>\n                    measurement.flushMeasurement()\n                );\n                this.deleteIncompleteSubMeasurements(inProgressEvent);\n            },\n        };\n    }\n\n    /**\n     * Adds pre-queue time to preQueueTimeByCorrelationId map.\n     * @param {PerformanceEvents} eventName\n     * @param {?string} correlationId\n     * @returns\n     */\n    setPreQueueTime(\n        eventName: PerformanceEvents,\n        correlationId?: string\n    ): void {\n        if (!supportsBrowserPerformanceNow()) {\n            this.logger.trace(\n                `BrowserPerformanceClient: window performance API not available, unable to set telemetry queue time for ${eventName}`\n            );\n            return;\n        }\n\n        if (!correlationId) {\n            this.logger.trace(\n                `BrowserPerformanceClient: correlationId for ${eventName} not provided, unable to set telemetry queue time`\n            );\n            return;\n        }\n\n        const preQueueEvent: PreQueueEvent | undefined =\n            this.preQueueTimeByCorrelationId.get(correlationId);\n        /**\n         * Manually complete queue measurement if there is an incomplete pre-queue event.\n         * Incomplete pre-queue events are instrumentation bugs that should be fixed.\n         */\n        if (preQueueEvent) {\n            this.logger.trace(\n                `BrowserPerformanceClient: Incomplete pre-queue ${preQueueEvent.name} found`,\n                correlationId\n            );\n            this.addQueueMeasurement(\n                preQueueEvent.name,\n                correlationId,\n                undefined,\n                true\n            );\n        }\n        this.preQueueTimeByCorrelationId.set(correlationId, {\n            name: eventName,\n            time: window.performance.now(),\n        });\n    }\n\n    /**\n     * Calculates and adds queue time measurement for given performance event.\n     *\n     * @param {PerformanceEvents} eventName\n     * @param {?string} correlationId\n     * @param {?number} queueTime\n     * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\n     * @returns\n     */\n    addQueueMeasurement(\n        eventName: string,\n        correlationId?: string,\n        queueTime?: number,\n        manuallyCompleted?: boolean\n    ): void {\n        if (!supportsBrowserPerformanceNow()) {\n            this.logger.trace(\n                `BrowserPerformanceClient: window performance API not available, unable to add queue measurement for ${eventName}`\n            );\n            return;\n        }\n\n        if (!correlationId) {\n            this.logger.trace(\n                `BrowserPerformanceClient: correlationId for ${eventName} not provided, unable to add queue measurement`\n            );\n            return;\n        }\n\n        const preQueueTime = super.getPreQueueTime(eventName, correlationId);\n        if (!preQueueTime) {\n            return;\n        }\n\n        const currentTime = window.performance.now();\n        const resQueueTime =\n            queueTime || super.calculateQueuedTime(preQueueTime, currentTime);\n\n        return super.addQueueMeasurement(\n            eventName,\n            correlationId,\n            resQueueTime,\n            manuallyCompleted\n        );\n    }\n}\n"],"mappings":";;;;;;;;AAAA;;;AAGG;AAqBH;;AAEG;AACH,SAASA,wBAAwBA,CAAA;EAC7B,IAAIC,cAAmC;EACvC,IAAI;IAAA,IAAAC,eAAA;IACAD,cAAc,GAAGE,MAAM,CAACC,oBAAoB,CAACC,cAAc,CAAC;IAC5D,MAAMC,WAAW,IAAAJ,eAAA,GAAGD,cAAc,cAAAC,eAAA,uBAAdA,eAAA,CAAgBK,OAAO,CAACC,wBAAwB,CAAC;IACrE,IAAIC,MAAM,CAACH,WAAW,CAAC,KAAK,CAAC,EAAE;MAC3B,OAAO,OAAO,qCAAoC,CAAC;IACtD;;EAEJ,EAAC,OAAOI,CAAC,EAAE;EAEZ,OAAOC,SAAS;AACpB;AAEA;;AAEG;AACH,SAASC,6BAA6BA,CAAA;EAClC,OACI,OAAOT,MAAM,KAAK,WAAW,IAC7B,OAAOA,MAAM,CAACU,WAAW,KAAK,WAAW,IACzC,OAAOV,MAAM,CAACU,WAAW,CAACC,GAAG,KAAK,UAAU;AAEpD;AAEA;;;;AAIG;AACH,SAASC,iBAAiBA,CACtBC,SAA0C;EAE1C,IAAI,CAACA,SAAS,IAAI,CAACJ,6BAA6B,EAAE,EAAE;IAChD,OAAOD,SAAS;EACnB;EAED,OAAOM,IAAI,CAACC,KAAK,CAACf,MAAM,CAACU,WAAW,CAACC,GAAG,EAAE,GAAGE,SAAS,CAAC;AAC3D;AAEM,MAAOG,wBACT,SAAQC,iBAAiB;EAGzBC,YACIC,aAA4B,EAC5BC,SAAuB,EACvBC,aAAmC;IAAA,IAAAC,qBAAA,EAAAC,qBAAA;IAEnC,KAAK,CACDJ,aAAa,CAACK,IAAI,CAACC,QAAQ,EAC3BN,aAAa,CAACK,IAAI,CAACE,SAAS,IAAI,GAAGC,SAAS,CAACC,iBAAiB,EAAE,EAChE,IAAIC,MAAM,CACN,EAAAP,qBAAA,GAAAH,aAAa,CAACW,MAAM,cAAAR,qBAAA,uBAApBA,qBAAA,CAAsBS,aAAa,KAAI,EAAE,EACzCC,IAAI,EACJC,OAAO,CACV,EACDD,IAAI,EACJC,OAAO,EACP,EAAAV,qBAAA,GAAAJ,aAAa,CAACe,SAAS,cAAAX,qBAAA,uBAAvBA,qBAAA,CAAyBY,WAAW,KAAI;MACpCC,OAAO,EAAE,EAAE;MACXC,UAAU,EAAE;IACf,GACDjB,SAAS,EACTC,aAAa,CAChB;;EAGLiB,UAAUA,CAAA;IACN,OAAOC,aAA2B,EAAE;;EAGhCC,iBAAiBA,CAAA;IAAA,IAAAC,qBAAA;IACrB,OAAO,EAAAA,qBAAA,GAAAC,QAAQ,CAACC,eAAe,cAAAF,qBAAA,uBAAxBA,qBAAA,CAA0BG,QAAQ,EAAE,KAAI,IAAI;;EAG/CC,+BAA+BA,CACnCC,eAA2C;IAAA,IAAAC,qBAAA;IAE3C,OAAAA,qBAAA,GAAKlD,wBAAwB,EAAE,cAAAkD,qBAAA,uBAA1BA,qBAAA,CAA4BC,IAAI,CAAEC,MAAM,IAAI;MAC7C,MAAMC,SAAS,GAAG,IAAI,CAACC,qBAAqB,CAACC,GAAG,CAC5CN,eAAe,CAACO,KAAK,CAACC,aAAa,CACtC;MACD,MAAMC,WAAW,GACbL,SAAS,IACTA,SAAS,CAACM,OAAO,KAAKV,eAAe,CAACO,KAAK,CAACG,OAAO;MACvD,MAAMC,sBAAsB,GAAqB,EAAE;MACnD,IAAIF,WAAW,IAAIL,SAAS,aAATA,SAAS,eAATA,SAAS,CAAEQ,yBAAyB,EAAE;QACrDR,SAAS,CAACQ,yBAAyB,CAACC,OAAO,CACtCC,cAA8B,IAAI;UAC/BH,sBAAsB,CAACI,IAAI,CAAC;YAAE,GAAGD;UAAc,CAAE,CAAC;QACtD,CAAC,CACJ;MACJ;;MAEDX,MAAM,CAACa,6BAA6B,CAACC,iBAAiB,CAClDjB,eAAe,CAACO,KAAK,CAACC,aAAa,EACnCG,sBAAsB,CACzB;IACL,CAAC,CAAC;;EAGN;;;;;;;AAOG;EACHO,gBAAgBA,CACZC,WAAmB,EACnBX,aAAsB;IAAA,IAAAY,sBAAA;;IAGtB,MAAMC,mBAAmB,GAAG,IAAI,CAAC3B,iBAAiB,EAAE;IACpD,MAAMM,eAAe,GAAG,KAAK,CAACkB,gBAAgB,CAC1CC,WAAW,EACXX,aAAa,CAChB;IACD,MAAMzC,SAAS,GAAuBJ,6BAA6B,EAAE,GAC/DT,MAAM,CAACU,WAAW,CAACC,GAAG,EAAE,GACxBH,SAAS;IAEf,MAAM4D,kBAAkB,IAAAF,sBAAA,GAAGrE,wBAAwB,EAAE,cAAAqE,sBAAA,uBAA1BA,sBAAA,CAA4BlB,IAAI,CACtDC,MAAM,IAAI;MACP,OAAO,IAAIA,MAAM,CAACa,6BAA6B,CAC3CG,WAAW,EACXnB,eAAe,CAACO,KAAK,CAACC,aAAa,CACtC;IACL,CAAC,CACJ;IACD,MAAKc,kBAAkB,aAAlBA,kBAAkB,uBAAlBA,kBAAkB,CAAEpB,IAAI,CAAEqB,WAAW,IACtCA,WAAW,CAACL,gBAAgB,EAAE,CACjC;IAED,OAAO;MACH,GAAGlB,eAAe;MAClBwB,GAAG,EAAEA,CACDjB,KAAiC,EACjCkB,KAAe,KACU;QACzB,MAAMC,GAAG,GAAG1B,eAAe,CAACwB,GAAG,CAC3B;UACI,GAAGjB,KAAK;UACRc,mBAAmB;UACnBM,iBAAiB,EAAE,IAAI,CAACjC,iBAAiB,EAAE;UAC3CkC,UAAU,EAAE9D,iBAAiB,CAACC,SAAS;SAC1C,EACD0D,KAAK,CACR;QACD,MAAKH,kBAAkB,aAAlBA,kBAAkB,uBAAlBA,kBAAkB,CAAEpB,IAAI,CAAEqB,WAAW,IACtCA,WAAW,CAACM,cAAc,EAAE,CAC/B;QACD,IAAI,CAAC9B,+BAA+B,CAACC,eAAe,CAAC;QAErD,OAAO0B,GAAG;OACb;MACDI,OAAO,EAAEA,CAAA,KAAK;QACV9B,eAAe,CAAC8B,OAAO,EAAE;QACzB,MAAKR,kBAAkB,aAAlBA,kBAAkB,uBAAlBA,kBAAkB,CAAEpB,IAAI,CAAEqB,WAAW,IACtCA,WAAW,CAACQ,gBAAgB,EAAE,CACjC;QACD,IAAI,CAAChC,+BAA+B,CAACC,eAAe,CAAC;;KAE5D;;EAGL;;;;;AAKG;EACHgC,eAAeA,CACXC,SAA4B,EAC5BzB,aAAsB;IAEtB,IAAI,CAAC7C,6BAA6B,EAAE,EAAE;MAClC,IAAI,CAACuE,MAAM,CAACC,KAAK,CACb,0GAA0GF,SAAS,EAAE,CACxH;MACD;IACH;IAED,IAAI,CAACzB,aAAa,EAAE;MAChB,IAAI,CAAC0B,MAAM,CAACC,KAAK,CACb,+CAA+CF,SAAS,mDAAmD,CAC9G;MACD;IACH;IAED,MAAMG,aAAa,GACf,IAAI,CAACC,2BAA2B,CAAC/B,GAAG,CAACE,aAAa,CAAC;IACvD;;;AAGG;IACH,IAAI4B,aAAa,EAAE;MACf,IAAI,CAACF,MAAM,CAACC,KAAK,CACb,kDAAkDC,aAAa,CAAClD,IAAI,QAAQ,EAC5EsB,aAAa,CAChB;MACD,IAAI,CAAC8B,mBAAmB,CACpBF,aAAa,CAAClD,IAAI,EAClBsB,aAAa,EACb9C,SAAS,EACT,IAAI,CACP;IACJ;IACD,IAAI,CAAC2E,2BAA2B,CAACE,GAAG,CAAC/B,aAAa,EAAE;MAChDtB,IAAI,EAAE+C,SAAS;MACfO,IAAI,EAAEtF,MAAM,CAACU,WAAW,CAACC,GAAG;IAC/B,EAAC;;EAGN;;;;;;;;AAQG;EACHyE,mBAAmBA,CACfL,SAAiB,EACjBzB,aAAsB,EACtBiC,SAAkB,EAClBC,iBAA2B;IAE3B,IAAI,CAAC/E,6BAA6B,EAAE,EAAE;MAClC,IAAI,CAACuE,MAAM,CAACC,KAAK,CACb,uGAAuGF,SAAS,EAAE,CACrH;MACD;IACH;IAED,IAAI,CAACzB,aAAa,EAAE;MAChB,IAAI,CAAC0B,MAAM,CAACC,KAAK,CACb,+CAA+CF,SAAS,gDAAgD,CAC3G;MACD;IACH;IAED,MAAMU,YAAY,GAAG,KAAK,CAACC,eAAe,CAACX,SAAS,EAAEzB,aAAa,CAAC;IACpE,IAAI,CAACmC,YAAY,EAAE;MACf;IACH;IAED,MAAME,WAAW,GAAG3F,MAAM,CAACU,WAAW,CAACC,GAAG,EAAE;IAC5C,MAAMiF,YAAY,GACdL,SAAS,IAAI,KAAK,CAACM,mBAAmB,CAACJ,YAAY,EAAEE,WAAW,CAAC;IAErE,OAAO,KAAK,CAACP,mBAAmB,CAC5BL,SAAS,EACTzB,aAAa,EACbsC,YAAY,EACZJ,iBAAiB,CACpB;;AAER","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}