{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { DefaultScopeSuffix } from \"./constants\";\n/**\n * Most MSIs send requests to the IMDS endpoint, or a similar endpoint.\n * These are GET requests that require sending a `resource` parameter on the query.\n * This resource can be derived from the scopes received through the getToken call, as long as only one scope is received.\n * Multiple scopes assume that the resulting token will have access to multiple resources, which won't be the case.\n *\n * For that reason, when we encounter multiple scopes, we return undefined.\n * It's up to the individual MSI implementations to throw the errors (which helps us provide less generic errors).\n */\nexport function mapScopesToResource(scopes) {\n  let scope = \"\";\n  if (Array.isArray(scopes)) {\n    if (scopes.length !== 1) {\n      return;\n    }\n    scope = scopes[0];\n  } else if (typeof scopes === \"string\") {\n    scope = scopes;\n  }\n  if (!scope.endsWith(DefaultScopeSuffix)) {\n    return scope;\n  }\n  return scope.substr(0, scope.lastIndexOf(DefaultScopeSuffix));\n}\n/**\n * Given a token response, return the expiration timestamp as the number of milliseconds from the Unix epoch.\n * @param body - A parsed response body from the authentication endpoint.\n */\nexport function parseExpirationTimestamp(body) {\n  if (typeof body.expires_on === \"number\") {\n    return body.expires_on * 1000;\n  }\n  if (typeof body.expires_on === \"string\") {\n    const asNumber = +body.expires_on;\n    if (!isNaN(asNumber)) {\n      return asNumber * 1000;\n    }\n    const asDate = Date.parse(body.expires_on);\n    if (!isNaN(asDate)) {\n      return asDate;\n    }\n  }\n  if (typeof body.expires_in === \"number\") {\n    return Date.now() + body.expires_in * 1000;\n  }\n  throw new Error(`Failed to parse token expiration from body. expires_in=\"${body.expires_in}\", expires_on=\"${body.expires_on}\"`);\n}\n/**\n * Given a token response, return the expiration timestamp as the number of milliseconds from the Unix epoch.\n * @param body - A parsed response body from the authentication endpoint.\n */\nexport function parseRefreshTimestamp(body) {\n  if (body.refresh_on) {\n    if (typeof body.refresh_on === \"number\") {\n      return body.refresh_on * 1000;\n    }\n    if (typeof body.refresh_on === \"string\") {\n      const asNumber = +body.refresh_on;\n      if (!isNaN(asNumber)) {\n        return asNumber * 1000;\n      }\n      const asDate = Date.parse(body.refresh_on);\n      if (!isNaN(asDate)) {\n        return asDate;\n      }\n    }\n    throw new Error(`Failed to parse refresh_on from body. refresh_on=\"${body.refresh_on}\"`);\n  } else {\n    return undefined;\n  }\n}","map":{"version":3,"names":["DefaultScopeSuffix","mapScopesToResource","scopes","scope","Array","isArray","length","endsWith","substr","lastIndexOf","parseExpirationTimestamp","body","expires_on","asNumber","isNaN","asDate","Date","parse","expires_in","now","Error","parseRefreshTimestamp","refresh_on","undefined"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\@azure\\identity\\src\\credentials\\managedIdentityCredential\\utils.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { DefaultScopeSuffix } from \"./constants\";\n\n/**\n * Most MSIs send requests to the IMDS endpoint, or a similar endpoint.\n * These are GET requests that require sending a `resource` parameter on the query.\n * This resource can be derived from the scopes received through the getToken call, as long as only one scope is received.\n * Multiple scopes assume that the resulting token will have access to multiple resources, which won't be the case.\n *\n * For that reason, when we encounter multiple scopes, we return undefined.\n * It's up to the individual MSI implementations to throw the errors (which helps us provide less generic errors).\n */\nexport function mapScopesToResource(scopes: string | string[]): string | undefined {\n  let scope = \"\";\n  if (Array.isArray(scopes)) {\n    if (scopes.length !== 1) {\n      return;\n    }\n\n    scope = scopes[0];\n  } else if (typeof scopes === \"string\") {\n    scope = scopes;\n  }\n\n  if (!scope.endsWith(DefaultScopeSuffix)) {\n    return scope;\n  }\n\n  return scope.substr(0, scope.lastIndexOf(DefaultScopeSuffix));\n}\n\n/**\n * Internal type roughly matching the raw responses of the authentication endpoints.\n *\n * @internal\n */\nexport interface TokenResponseParsedBody {\n  access_token?: string;\n  refresh_token?: string;\n  expires_in: number;\n  expires_on?: number | string;\n  refresh_on?: number | string;\n}\n\n/**\n * Given a token response, return the expiration timestamp as the number of milliseconds from the Unix epoch.\n * @param body - A parsed response body from the authentication endpoint.\n */\nexport function parseExpirationTimestamp(body: TokenResponseParsedBody): number {\n  if (typeof body.expires_on === \"number\") {\n    return body.expires_on * 1000;\n  }\n\n  if (typeof body.expires_on === \"string\") {\n    const asNumber = +body.expires_on;\n    if (!isNaN(asNumber)) {\n      return asNumber * 1000;\n    }\n\n    const asDate = Date.parse(body.expires_on);\n    if (!isNaN(asDate)) {\n      return asDate;\n    }\n  }\n\n  if (typeof body.expires_in === \"number\") {\n    return Date.now() + body.expires_in * 1000;\n  }\n\n  throw new Error(\n    `Failed to parse token expiration from body. expires_in=\"${body.expires_in}\", expires_on=\"${body.expires_on}\"`,\n  );\n}\n\n/**\n * Given a token response, return the expiration timestamp as the number of milliseconds from the Unix epoch.\n * @param body - A parsed response body from the authentication endpoint.\n */\nexport function parseRefreshTimestamp(body: TokenResponseParsedBody): number | undefined {\n  if (body.refresh_on) {\n    if (typeof body.refresh_on === \"number\") {\n      return body.refresh_on * 1000;\n    }\n\n    if (typeof body.refresh_on === \"string\") {\n      const asNumber = +body.refresh_on;\n      if (!isNaN(asNumber)) {\n        return asNumber * 1000;\n      }\n\n      const asDate = Date.parse(body.refresh_on);\n      if (!isNaN(asDate)) {\n        return asDate;\n      }\n    }\n    throw new Error(`Failed to parse refresh_on from body. refresh_on=\"${body.refresh_on}\"`);\n  } else {\n    return undefined;\n  }\n}\n"],"mappings":"AAAA;AACA;AAEA,SAASA,kBAAkB,QAAQ,aAAa;AAEhD;;;;;;;;;AASA,OAAM,SAAUC,mBAAmBA,CAACC,MAAyB;EAC3D,IAAIC,KAAK,GAAG,EAAE;EACd,IAAIC,KAAK,CAACC,OAAO,CAACH,MAAM,CAAC,EAAE;IACzB,IAAIA,MAAM,CAACI,MAAM,KAAK,CAAC,EAAE;MACvB;IACF;IAEAH,KAAK,GAAGD,MAAM,CAAC,CAAC,CAAC;EACnB,CAAC,MAAM,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;IACrCC,KAAK,GAAGD,MAAM;EAChB;EAEA,IAAI,CAACC,KAAK,CAACI,QAAQ,CAACP,kBAAkB,CAAC,EAAE;IACvC,OAAOG,KAAK;EACd;EAEA,OAAOA,KAAK,CAACK,MAAM,CAAC,CAAC,EAAEL,KAAK,CAACM,WAAW,CAACT,kBAAkB,CAAC,CAAC;AAC/D;AAeA;;;;AAIA,OAAM,SAAUU,wBAAwBA,CAACC,IAA6B;EACpE,IAAI,OAAOA,IAAI,CAACC,UAAU,KAAK,QAAQ,EAAE;IACvC,OAAOD,IAAI,CAACC,UAAU,GAAG,IAAI;EAC/B;EAEA,IAAI,OAAOD,IAAI,CAACC,UAAU,KAAK,QAAQ,EAAE;IACvC,MAAMC,QAAQ,GAAG,CAACF,IAAI,CAACC,UAAU;IACjC,IAAI,CAACE,KAAK,CAACD,QAAQ,CAAC,EAAE;MACpB,OAAOA,QAAQ,GAAG,IAAI;IACxB;IAEA,MAAME,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACN,IAAI,CAACC,UAAU,CAAC;IAC1C,IAAI,CAACE,KAAK,CAACC,MAAM,CAAC,EAAE;MAClB,OAAOA,MAAM;IACf;EACF;EAEA,IAAI,OAAOJ,IAAI,CAACO,UAAU,KAAK,QAAQ,EAAE;IACvC,OAAOF,IAAI,CAACG,GAAG,EAAE,GAAGR,IAAI,CAACO,UAAU,GAAG,IAAI;EAC5C;EAEA,MAAM,IAAIE,KAAK,CACb,2DAA2DT,IAAI,CAACO,UAAU,kBAAkBP,IAAI,CAACC,UAAU,GAAG,CAC/G;AACH;AAEA;;;;AAIA,OAAM,SAAUS,qBAAqBA,CAACV,IAA6B;EACjE,IAAIA,IAAI,CAACW,UAAU,EAAE;IACnB,IAAI,OAAOX,IAAI,CAACW,UAAU,KAAK,QAAQ,EAAE;MACvC,OAAOX,IAAI,CAACW,UAAU,GAAG,IAAI;IAC/B;IAEA,IAAI,OAAOX,IAAI,CAACW,UAAU,KAAK,QAAQ,EAAE;MACvC,MAAMT,QAAQ,GAAG,CAACF,IAAI,CAACW,UAAU;MACjC,IAAI,CAACR,KAAK,CAACD,QAAQ,CAAC,EAAE;QACpB,OAAOA,QAAQ,GAAG,IAAI;MACxB;MAEA,MAAME,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACN,IAAI,CAACW,UAAU,CAAC;MAC1C,IAAI,CAACR,KAAK,CAACC,MAAM,CAAC,EAAE;QAClB,OAAOA,MAAM;MACf;IACF;IACA,MAAM,IAAIK,KAAK,CAAC,qDAAqDT,IAAI,CAACW,UAAU,GAAG,CAAC;EAC1F,CAAC,MAAM;IACL,OAAOC,SAAS;EAClB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}