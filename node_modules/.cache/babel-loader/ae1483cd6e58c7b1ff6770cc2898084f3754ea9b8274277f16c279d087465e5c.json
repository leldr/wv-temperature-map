{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.connectInParallel = connectInParallel;\nexports.connectInSequence = connectInSequence;\nexports.lookupAllAddresses = lookupAllAddresses;\nvar _net = _interopRequireDefault(require(\"net\"));\nvar _nodeUrl = _interopRequireDefault(require(\"node:url\"));\nvar _abortError = _interopRequireDefault(require(\"./errors/abort-error\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nasync function connectInParallel(options, lookup, signal) {\n  if (signal.aborted) {\n    throw new _abortError.default();\n  }\n  const addresses = await lookupAllAddresses(options.host, lookup, signal);\n  return await new Promise((resolve, reject) => {\n    const sockets = new Array(addresses.length);\n    const errors = [];\n    function onError(err) {\n      errors.push(err);\n      this.removeListener('error', onError);\n      this.removeListener('connect', onConnect);\n      this.destroy();\n      if (errors.length === addresses.length) {\n        signal.removeEventListener('abort', onAbort);\n        reject(new AggregateError(errors, 'Could not connect (parallel)'));\n      }\n    }\n    function onConnect() {\n      signal.removeEventListener('abort', onAbort);\n      for (let j = 0; j < sockets.length; j++) {\n        const socket = sockets[j];\n        if (this === socket) {\n          continue;\n        }\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n        socket.destroy();\n      }\n      resolve(this);\n    }\n    const onAbort = () => {\n      for (let j = 0; j < sockets.length; j++) {\n        const socket = sockets[j];\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n        socket.destroy();\n      }\n      reject(new _abortError.default());\n    };\n    for (let i = 0, len = addresses.length; i < len; i++) {\n      const socket = sockets[i] = _net.default.connect({\n        ...options,\n        host: addresses[i].address,\n        family: addresses[i].family\n      });\n      socket.on('error', onError);\n      socket.on('connect', onConnect);\n    }\n    signal.addEventListener('abort', onAbort, {\n      once: true\n    });\n  });\n}\nasync function connectInSequence(options, lookup, signal) {\n  if (signal.aborted) {\n    throw new _abortError.default();\n  }\n  const errors = [];\n  const addresses = await lookupAllAddresses(options.host, lookup, signal);\n  for (const address of addresses) {\n    try {\n      return await new Promise((resolve, reject) => {\n        const socket = _net.default.connect({\n          ...options,\n          host: address.address,\n          family: address.family\n        });\n        const onAbort = () => {\n          socket.removeListener('error', onError);\n          socket.removeListener('connect', onConnect);\n          socket.destroy();\n          reject(new _abortError.default());\n        };\n        const onError = err => {\n          signal.removeEventListener('abort', onAbort);\n          socket.removeListener('error', onError);\n          socket.removeListener('connect', onConnect);\n          socket.destroy();\n          reject(err);\n        };\n        const onConnect = () => {\n          signal.removeEventListener('abort', onAbort);\n          socket.removeListener('error', onError);\n          socket.removeListener('connect', onConnect);\n          resolve(socket);\n        };\n        signal.addEventListener('abort', onAbort, {\n          once: true\n        });\n        socket.on('error', onError);\n        socket.on('connect', onConnect);\n      });\n    } catch (err) {\n      if (err instanceof Error && err.name === 'AbortError') {\n        throw err;\n      }\n      errors.push(err);\n      continue;\n    }\n  }\n  throw new AggregateError(errors, 'Could not connect (sequence)');\n}\n\n/**\n * Look up all addresses for the given hostname.\n */\nasync function lookupAllAddresses(host, lookup, signal) {\n  if (signal.aborted) {\n    throw new _abortError.default();\n  }\n  if (_net.default.isIPv6(host)) {\n    return [{\n      address: host,\n      family: 6\n    }];\n  } else if (_net.default.isIPv4(host)) {\n    return [{\n      address: host,\n      family: 4\n    }];\n  } else {\n    return await new Promise((resolve, reject) => {\n      const onAbort = () => {\n        reject(new _abortError.default());\n      };\n      signal.addEventListener('abort', onAbort);\n      const domainInASCII = _nodeUrl.default.domainToASCII(host);\n      lookup(domainInASCII === '' ? host : domainInASCII, {\n        all: true\n      }, (err, addresses) => {\n        signal.removeEventListener('abort', onAbort);\n        err ? reject(err) : resolve(addresses);\n      });\n    });\n  }\n}","map":{"version":3,"names":["_net","_interopRequireDefault","require","_nodeUrl","_abortError","obj","__esModule","default","connectInParallel","options","lookup","signal","aborted","addresses","lookupAllAddresses","host","Promise","resolve","reject","sockets","Array","length","errors","onError","err","push","removeListener","onConnect","destroy","removeEventListener","onAbort","AggregateError","j","socket","i","len","connect","address","family","on","addEventListener","once","connectInSequence","Error","name","isIPv6","isIPv4","domainInASCII","domainToASCII","all"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\tedious\\src\\connector.ts"],"sourcesContent":["import net from 'net';\nimport dns, { type LookupAddress } from 'dns';\n\nimport url from 'node:url';\nimport AbortError from './errors/abort-error';\n\ntype LookupFunction = (hostname: string, options: dns.LookupAllOptions, callback: (err: NodeJS.ErrnoException | null, addresses: dns.LookupAddress[]) => void) => void;\n\nexport async function connectInParallel(options: { host: string, port: number, localAddress?: string | undefined }, lookup: LookupFunction, signal: AbortSignal) {\n  if (signal.aborted) {\n    throw new AbortError();\n  }\n\n  const addresses = await lookupAllAddresses(options.host, lookup, signal);\n\n  return await new Promise<net.Socket>((resolve, reject) => {\n    const sockets = new Array(addresses.length);\n\n    const errors: Error[] = [];\n\n    function onError(this: net.Socket, err: Error) {\n      errors.push(err);\n\n      this.removeListener('error', onError);\n      this.removeListener('connect', onConnect);\n\n      this.destroy();\n\n      if (errors.length === addresses.length) {\n        signal.removeEventListener('abort', onAbort);\n\n        reject(new AggregateError(errors, 'Could not connect (parallel)'));\n      }\n    }\n\n    function onConnect(this: net.Socket) {\n      signal.removeEventListener('abort', onAbort);\n\n      for (let j = 0; j < sockets.length; j++) {\n        const socket = sockets[j];\n\n        if (this === socket) {\n          continue;\n        }\n\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n        socket.destroy();\n      }\n\n      resolve(this);\n    }\n\n    const onAbort = () => {\n      for (let j = 0; j < sockets.length; j++) {\n        const socket = sockets[j];\n\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n\n        socket.destroy();\n      }\n\n      reject(new AbortError());\n    };\n\n    for (let i = 0, len = addresses.length; i < len; i++) {\n      const socket = sockets[i] = net.connect({\n        ...options,\n        host: addresses[i].address,\n        family: addresses[i].family\n      });\n\n      socket.on('error', onError);\n      socket.on('connect', onConnect);\n    }\n\n    signal.addEventListener('abort', onAbort, { once: true });\n  });\n}\n\nexport async function connectInSequence(options: { host: string, port: number, localAddress?: string | undefined }, lookup: LookupFunction, signal: AbortSignal) {\n  if (signal.aborted) {\n    throw new AbortError();\n  }\n\n  const errors: any[] = [];\n  const addresses = await lookupAllAddresses(options.host, lookup, signal);\n\n  for (const address of addresses) {\n    try {\n      return await new Promise<net.Socket>((resolve, reject) => {\n        const socket = net.connect({\n          ...options,\n          host: address.address,\n          family: address.family\n        });\n\n        const onAbort = () => {\n          socket.removeListener('error', onError);\n          socket.removeListener('connect', onConnect);\n\n          socket.destroy();\n\n          reject(new AbortError());\n        };\n\n        const onError = (err: Error) => {\n          signal.removeEventListener('abort', onAbort);\n\n          socket.removeListener('error', onError);\n          socket.removeListener('connect', onConnect);\n\n          socket.destroy();\n\n          reject(err);\n        };\n\n        const onConnect = () => {\n          signal.removeEventListener('abort', onAbort);\n\n          socket.removeListener('error', onError);\n          socket.removeListener('connect', onConnect);\n\n          resolve(socket);\n        };\n\n        signal.addEventListener('abort', onAbort, { once: true });\n\n        socket.on('error', onError);\n        socket.on('connect', onConnect);\n      });\n    } catch (err) {\n      if (err instanceof Error && err.name === 'AbortError') {\n        throw err;\n      }\n\n      errors.push(err);\n\n      continue;\n    }\n  }\n\n  throw new AggregateError(errors, 'Could not connect (sequence)');\n}\n\n/**\n * Look up all addresses for the given hostname.\n */\nexport async function lookupAllAddresses(host: string, lookup: LookupFunction, signal: AbortSignal): Promise<dns.LookupAddress[]> {\n  if (signal.aborted) {\n    throw new AbortError();\n  }\n\n  if (net.isIPv6(host)) {\n    return [{ address: host, family: 6 }];\n  } else if (net.isIPv4(host)) {\n    return [{ address: host, family: 4 }];\n  } else {\n    return await new Promise<LookupAddress[]>((resolve, reject) => {\n      const onAbort = () => {\n        reject(new AbortError());\n      };\n\n      signal.addEventListener('abort', onAbort);\n\n      const domainInASCII = url.domainToASCII(host);\n      lookup(domainInASCII === '' ? host : domainInASCII, { all: true }, (err, addresses) => {\n        signal.removeEventListener('abort', onAbort);\n\n        err ? reject(err) : resolve(addresses);\n      });\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}