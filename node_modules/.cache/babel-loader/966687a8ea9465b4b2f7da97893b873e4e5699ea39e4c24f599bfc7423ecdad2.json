{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./interfaces.js\";\nimport { getOperationArgumentValueFromParameter, getOperationRequestInfo } from \"./operationHelpers.js\";\nimport { MapperTypeNames } from \"./serializer.js\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers.js\";\n/**\n * The programmatic identifier of the serializationPolicy.\n */\nexport const serializationPolicyName = \"serializationPolicy\";\n/**\n * This policy handles assembling the request body and headers using\n * an OperationSpec and OperationArguments on the request.\n */\nexport function serializationPolicy(options = {}) {\n  const stringifyXML = options.stringifyXML;\n  return {\n    name: serializationPolicyName,\n    async sendRequest(request, next) {\n      const operationInfo = getOperationRequestInfo(request);\n      const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n      const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;\n      if (operationSpec && operationArguments) {\n        serializeHeaders(request, operationArguments, operationSpec);\n        serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);\n      }\n      return next(request);\n    }\n  };\n}\n/**\n * @internal\n */\nexport function serializeHeaders(request, operationArguments, operationSpec) {\n  var _a, _b;\n  if (operationSpec.headerParameters) {\n    for (const headerParameter of operationSpec.headerParameters) {\n      let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);\n      if (headerValue !== null && headerValue !== undefined || headerParameter.mapper.required) {\n        headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));\n        const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;\n        if (headerCollectionPrefix) {\n          for (const key of Object.keys(headerValue)) {\n            request.headers.set(headerCollectionPrefix + key, headerValue[key]);\n          }\n        } else {\n          request.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n        }\n      }\n    }\n  }\n  const customHeaders = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.requestOptions) === null || _b === void 0 ? void 0 : _b.customHeaders;\n  if (customHeaders) {\n    for (const customHeaderName of Object.keys(customHeaders)) {\n      request.headers.set(customHeaderName, customHeaders[customHeaderName]);\n    }\n  }\n}\n/**\n * @internal\n */\nexport function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function () {\n  throw new Error(\"XML serialization unsupported!\");\n}) {\n  var _a, _b, _c, _d, _e;\n  const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n  const updatedOptions = {\n    xml: {\n      rootName: (_b = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b !== void 0 ? _b : \"\",\n      includeRoot: (_c = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c !== void 0 ? _c : false,\n      xmlCharKey: (_d = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d !== void 0 ? _d : XML_CHARKEY\n    }\n  };\n  const xmlCharKey = updatedOptions.xml.xmlCharKey;\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    request.body = getOperationArgumentValueFromParameter(operationArguments, operationSpec.requestBody);\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const {\n      required,\n      serializedName,\n      xmlName,\n      xmlElementName,\n      xmlNamespace,\n      xmlNamespacePrefix,\n      nullable\n    } = bodyMapper;\n    const typeName = bodyMapper.type.name;\n    try {\n      if (request.body !== undefined && request.body !== null || nullable && request.body === null || required) {\n        const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n        request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);\n        const isStream = typeName === MapperTypeNames.Stream;\n        if (operationSpec.isXML) {\n          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n          const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);\n          if (typeName === MapperTypeNames.Sequence) {\n            request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {\n              rootName: xmlName || serializedName,\n              xmlCharKey\n            });\n          } else if (!isStream) {\n            request.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey\n            });\n          }\n        } else if (typeName === MapperTypeNames.String && (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          request.body = JSON.stringify(request.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(`Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, \"  \")}.`);\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    request.formData = {};\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue = getOperationArgumentValueFromParameter(operationArguments, formDataParameter);\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);\n      }\n    }\n  }\n}\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    const result = {};\n    result[options.xml.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = {\n      [xmlnsKey]: xmlNamespace\n    };\n    return result;\n  }\n  return serializedValue;\n}\nfunction prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {\n  if (!Array.isArray(obj)) {\n    obj = [obj];\n  }\n  if (!xmlNamespaceKey || !xmlNamespace) {\n    return {\n      [elementName]: obj\n    };\n  }\n  const result = {\n    [elementName]: obj\n  };\n  result[XML_ATTRKEY] = {\n    [xmlNamespaceKey]: xmlNamespace\n  };\n  return result;\n}","map":{"version":3,"names":["XML_ATTRKEY","XML_CHARKEY","getOperationArgumentValueFromParameter","getOperationRequestInfo","MapperTypeNames","getPathStringFromParameter","serializationPolicyName","serializationPolicy","options","stringifyXML","name","sendRequest","request","next","operationInfo","operationSpec","operationArguments","serializeHeaders","serializeRequestBody","headerParameters","headerParameter","headerValue","undefined","mapper","required","serializer","serialize","headerCollectionPrefix","key","Object","keys","headers","set","serializedName","customHeaders","_b","_a","requestOptions","customHeaderName","Error","serializerOptions","updatedOptions","xml","rootName","includeRoot","_c","xmlCharKey","_d","requestBody","body","bodyMapper","xmlName","xmlElementName","xmlNamespace","xmlNamespacePrefix","nullable","typeName","type","requestBodyParameterPathString","isStream","Stream","isXML","xmlnsKey","value","getXmlValueWithNamespace","Sequence","prepareXMLRootList","String","_e","contentType","match","mediaType","JSON","stringify","error","message","formDataParameters","length","formData","formDataParameter","formDataParameterValue","formDataParameterPropertyName","serializedValue","includes","result","obj","elementName","xmlNamespaceKey","Array","isArray"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\@azure\\core-client\\src\\serializationPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  DictionaryMapper,\n  OperationArguments,\n  OperationRequest,\n  OperationSpec,\n  RequiredSerializerOptions,\n  SerializerOptions,\n  XML_ATTRKEY,\n  XML_CHARKEY,\n  XmlOptions,\n} from \"./interfaces.js\";\nimport { PipelinePolicy, PipelineResponse, SendRequest } from \"@azure/core-rest-pipeline\";\nimport {\n  getOperationArgumentValueFromParameter,\n  getOperationRequestInfo,\n} from \"./operationHelpers.js\";\nimport { MapperTypeNames } from \"./serializer.js\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers.js\";\n\n/**\n * The programmatic identifier of the serializationPolicy.\n */\nexport const serializationPolicyName = \"serializationPolicy\";\n\n/**\n * Options to configure API request serialization.\n */\nexport interface SerializationPolicyOptions {\n  /**\n   * A function that is able to write XML. Required for XML support.\n   */\n  stringifyXML?: (obj: any, opts?: XmlOptions) => string;\n\n  /**\n   * Configures behavior of xml parser and builder.\n   */\n  serializerOptions?: SerializerOptions;\n}\n\n/**\n * This policy handles assembling the request body and headers using\n * an OperationSpec and OperationArguments on the request.\n */\nexport function serializationPolicy(options: SerializationPolicyOptions = {}): PipelinePolicy {\n  const stringifyXML = options.stringifyXML;\n\n  return {\n    name: serializationPolicyName,\n    async sendRequest(request: OperationRequest, next: SendRequest): Promise<PipelineResponse> {\n      const operationInfo = getOperationRequestInfo(request);\n      const operationSpec = operationInfo?.operationSpec;\n      const operationArguments = operationInfo?.operationArguments;\n      if (operationSpec && operationArguments) {\n        serializeHeaders(request, operationArguments, operationSpec);\n        serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);\n      }\n      return next(request);\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport function serializeHeaders(\n  request: OperationRequest,\n  operationArguments: OperationArguments,\n  operationSpec: OperationSpec,\n): void {\n  if (operationSpec.headerParameters) {\n    for (const headerParameter of operationSpec.headerParameters) {\n      let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);\n      if ((headerValue !== null && headerValue !== undefined) || headerParameter.mapper.required) {\n        headerValue = operationSpec.serializer.serialize(\n          headerParameter.mapper,\n          headerValue,\n          getPathStringFromParameter(headerParameter),\n        );\n        const headerCollectionPrefix = (headerParameter.mapper as DictionaryMapper)\n          .headerCollectionPrefix;\n        if (headerCollectionPrefix) {\n          for (const key of Object.keys(headerValue)) {\n            request.headers.set(headerCollectionPrefix + key, headerValue[key]);\n          }\n        } else {\n          request.headers.set(\n            headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter),\n            headerValue,\n          );\n        }\n      }\n    }\n  }\n  const customHeaders = operationArguments.options?.requestOptions?.customHeaders;\n  if (customHeaders) {\n    for (const customHeaderName of Object.keys(customHeaders)) {\n      request.headers.set(customHeaderName, customHeaders[customHeaderName]);\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport function serializeRequestBody(\n  request: OperationRequest,\n  operationArguments: OperationArguments,\n  operationSpec: OperationSpec,\n  stringifyXML: (obj: any, opts?: XmlOptions) => string = function () {\n    throw new Error(\"XML serialization unsupported!\");\n  },\n): void {\n  const serializerOptions = operationArguments.options?.serializerOptions;\n  const updatedOptions: RequiredSerializerOptions = {\n    xml: {\n      rootName: serializerOptions?.xml.rootName ?? \"\",\n      includeRoot: serializerOptions?.xml.includeRoot ?? false,\n      xmlCharKey: serializerOptions?.xml.xmlCharKey ?? XML_CHARKEY,\n    },\n  };\n\n  const xmlCharKey = updatedOptions.xml.xmlCharKey;\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    request.body = getOperationArgumentValueFromParameter(\n      operationArguments,\n      operationSpec.requestBody,\n    );\n\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const {\n      required,\n      serializedName,\n      xmlName,\n      xmlElementName,\n      xmlNamespace,\n      xmlNamespacePrefix,\n      nullable,\n    } = bodyMapper;\n    const typeName = bodyMapper.type.name;\n\n    try {\n      if (\n        (request.body !== undefined && request.body !== null) ||\n        (nullable && request.body === null) ||\n        required\n      ) {\n        const requestBodyParameterPathString: string = getPathStringFromParameter(\n          operationSpec.requestBody,\n        );\n        request.body = operationSpec.serializer.serialize(\n          bodyMapper,\n          request.body,\n          requestBodyParameterPathString,\n          updatedOptions,\n        );\n\n        const isStream = typeName === MapperTypeNames.Stream;\n\n        if (operationSpec.isXML) {\n          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n          const value = getXmlValueWithNamespace(\n            xmlNamespace,\n            xmlnsKey,\n            typeName,\n            request.body,\n            updatedOptions,\n          );\n\n          if (typeName === MapperTypeNames.Sequence) {\n            request.body = stringifyXML(\n              prepareXMLRootList(\n                value,\n                xmlElementName || xmlName || serializedName!,\n                xmlnsKey,\n                xmlNamespace,\n              ),\n              { rootName: xmlName || serializedName, xmlCharKey },\n            );\n          } else if (!isStream) {\n            request.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey,\n            });\n          }\n        } else if (\n          typeName === MapperTypeNames.String &&\n          (operationSpec.contentType?.match(\"text/plain\") || operationSpec.mediaType === \"text\")\n        ) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          request.body = JSON.stringify(request.body);\n        }\n      }\n    } catch (error: any) {\n      throw new Error(\n        `Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(\n          serializedName,\n          undefined,\n          \"  \",\n        )}.`,\n      );\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    request.formData = {};\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue = getOperationArgumentValueFromParameter(\n        operationArguments,\n        formDataParameter,\n      );\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        const formDataParameterPropertyName: string =\n          formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(\n          formDataParameter.mapper,\n          formDataParameterValue,\n          getPathStringFromParameter(formDataParameter),\n          updatedOptions,\n        );\n      }\n    }\n  }\n}\n\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(\n  xmlNamespace: string | undefined,\n  xmlnsKey: string,\n  typeName: string,\n  serializedValue: any,\n  options: RequiredSerializerOptions,\n): any {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    const result: any = {};\n    result[options.xml.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };\n    return result;\n  }\n\n  return serializedValue;\n}\n\nfunction prepareXMLRootList(\n  obj: any,\n  elementName: string,\n  xmlNamespaceKey?: string,\n  xmlNamespace?: string,\n): { [key: string]: any[] } {\n  if (!Array.isArray(obj)) {\n    obj = [obj];\n  }\n  if (!xmlNamespaceKey || !xmlNamespace) {\n    return { [elementName]: obj };\n  }\n\n  const result = { [elementName]: obj };\n  result[XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}