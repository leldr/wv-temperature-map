{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _bl = _interopRequireDefault(require(\"bl\"));\nvar _stream = require(\"stream\");\nvar _message = _interopRequireDefault(require(\"./message\"));\nvar _packet = require(\"./packet\");\nvar _errors = require(\"./errors\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n  IncomingMessageStream\n  Transform received TDS data into individual IncomingMessage streams.\n*/\nclass IncomingMessageStream extends _stream.Transform {\n  constructor(debug) {\n    super({\n      readableObjectMode: true\n    });\n    this.debug = debug;\n    this.currentMessage = undefined;\n    this.bl = new _bl.default();\n  }\n  pause() {\n    super.pause();\n    if (this.currentMessage) {\n      this.currentMessage.pause();\n    }\n    return this;\n  }\n  resume() {\n    super.resume();\n    if (this.currentMessage) {\n      this.currentMessage.resume();\n    }\n    return this;\n  }\n  processBufferedData(callback) {\n    // The packet header is always 8 bytes of length.\n    while (this.bl.length >= _packet.HEADER_LENGTH) {\n      // Get the full packet length\n      const length = this.bl.readUInt16BE(2);\n      if (length < _packet.HEADER_LENGTH) {\n        return callback(new _errors.ConnectionError('Unable to process incoming packet'));\n      }\n      if (this.bl.length >= length) {\n        const data = this.bl.slice(0, length);\n        this.bl.consume(length);\n\n        // TODO: Get rid of creating `Packet` instances here.\n        const packet = new _packet.Packet(data);\n        this.debug.packet('Received', packet);\n        this.debug.data(packet);\n        let message = this.currentMessage;\n        if (message === undefined) {\n          this.currentMessage = message = new _message.default({\n            type: packet.type(),\n            resetConnection: false\n          });\n          this.push(message);\n        }\n        if (packet.isLast()) {\n          // Wait until the current message was fully processed before we\n          // continue processing any remaining messages.\n          message.once('end', () => {\n            this.currentMessage = undefined;\n            this.processBufferedData(callback);\n          });\n          message.end(packet.data());\n          return;\n        } else if (!message.write(packet.data())) {\n          // If too much data is buffering up in the\n          // current message, wait for it to drain.\n          message.once('drain', () => {\n            this.processBufferedData(callback);\n          });\n          return;\n        }\n      } else {\n        break;\n      }\n    }\n\n    // Not enough data to read the next packet. Stop here and wait for\n    // the next call to `_transform`.\n    callback();\n  }\n  _transform(chunk, _encoding, callback) {\n    this.bl.append(chunk);\n    this.processBufferedData(callback);\n  }\n}\nvar _default = exports.default = IncomingMessageStream;\nmodule.exports = IncomingMessageStream;","map":{"version":3,"names":["_bl","_interopRequireDefault","require","_stream","_message","_packet","_errors","obj","__esModule","default","IncomingMessageStream","Transform","constructor","debug","readableObjectMode","currentMessage","undefined","bl","pause","resume","processBufferedData","callback","length","HEADER_LENGTH","readUInt16BE","ConnectionError","data","slice","consume","packet","Packet","message","type","resetConnection","push","isLast","once","end","write","_transform","chunk","_encoding","append","_default","exports","module"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\tedious\\src\\incoming-message-stream.ts"],"sourcesContent":["import BufferList from 'bl';\nimport { Transform } from 'stream';\n\nimport Debug from './debug';\nimport Message from './message';\nimport { Packet, HEADER_LENGTH } from './packet';\nimport { ConnectionError } from './errors';\n\n/**\n  IncomingMessageStream\n  Transform received TDS data into individual IncomingMessage streams.\n*/\nclass IncomingMessageStream extends Transform {\n  declare debug: Debug;\n  declare bl: any;\n  declare currentMessage: Message | undefined;\n\n  constructor(debug: Debug) {\n    super({ readableObjectMode: true });\n\n    this.debug = debug;\n\n    this.currentMessage = undefined;\n    this.bl = new BufferList();\n  }\n\n  pause() {\n    super.pause();\n\n    if (this.currentMessage) {\n      this.currentMessage.pause();\n    }\n\n    return this;\n  }\n\n  resume() {\n    super.resume();\n\n    if (this.currentMessage) {\n      this.currentMessage.resume();\n    }\n\n    return this;\n  }\n\n  processBufferedData(callback: (err?: ConnectionError) => void) {\n    // The packet header is always 8 bytes of length.\n    while (this.bl.length >= HEADER_LENGTH) {\n      // Get the full packet length\n      const length = this.bl.readUInt16BE(2);\n      if (length < HEADER_LENGTH) {\n        return callback(new ConnectionError('Unable to process incoming packet'));\n      }\n\n      if (this.bl.length >= length) {\n        const data = this.bl.slice(0, length);\n        this.bl.consume(length);\n\n        // TODO: Get rid of creating `Packet` instances here.\n        const packet = new Packet(data);\n        this.debug.packet('Received', packet);\n        this.debug.data(packet);\n\n        let message = this.currentMessage;\n        if (message === undefined) {\n          this.currentMessage = message = new Message({ type: packet.type(), resetConnection: false });\n          this.push(message);\n        }\n\n        if (packet.isLast()) {\n          // Wait until the current message was fully processed before we\n          // continue processing any remaining messages.\n          message.once('end', () => {\n            this.currentMessage = undefined;\n            this.processBufferedData(callback);\n          });\n          message.end(packet.data());\n          return;\n        } else if (!message.write(packet.data())) {\n          // If too much data is buffering up in the\n          // current message, wait for it to drain.\n          message.once('drain', () => {\n            this.processBufferedData(callback);\n          });\n          return;\n        }\n      } else {\n        break;\n      }\n    }\n\n    // Not enough data to read the next packet. Stop here and wait for\n    // the next call to `_transform`.\n    callback();\n  }\n\n  _transform(chunk: Buffer, _encoding: string, callback: () => void) {\n    this.bl.append(chunk);\n    this.processBufferedData(callback);\n  }\n}\n\nexport default IncomingMessageStream;\nmodule.exports = IncomingMessageStream;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}