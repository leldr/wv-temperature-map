{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { isNodeLike, stringToUint8Array } from \"@azure/core-util\";\nimport { createHttpHeaders } from \"../httpHeaders.js\";\n/**\n * The programmatic identifier of the formDataPolicy.\n */\nexport const formDataPolicyName = \"formDataPolicy\";\nfunction formDataToFormDataMap(formData) {\n  var _a;\n  const formDataMap = {};\n  for (const [key, value] of formData.entries()) {\n    (_a = formDataMap[key]) !== null && _a !== void 0 ? _a : formDataMap[key] = [];\n    formDataMap[key].push(value);\n  }\n  return formDataMap;\n}\n/**\n * A policy that encodes FormData on the request into the body.\n */\nexport function formDataPolicy() {\n  return {\n    name: formDataPolicyName,\n    async sendRequest(request, next) {\n      if (isNodeLike && typeof FormData !== \"undefined\" && request.body instanceof FormData) {\n        request.formData = formDataToFormDataMap(request.body);\n        request.body = undefined;\n      }\n      if (request.formData) {\n        const contentType = request.headers.get(\"Content-Type\");\n        if (contentType && contentType.indexOf(\"application/x-www-form-urlencoded\") !== -1) {\n          request.body = wwwFormUrlEncode(request.formData);\n        } else {\n          await prepareFormData(request.formData, request);\n        }\n        request.formData = undefined;\n      }\n      return next(request);\n    }\n  };\n}\nfunction wwwFormUrlEncode(formData) {\n  const urlSearchParams = new URLSearchParams();\n  for (const [key, value] of Object.entries(formData)) {\n    if (Array.isArray(value)) {\n      for (const subValue of value) {\n        urlSearchParams.append(key, subValue.toString());\n      }\n    } else {\n      urlSearchParams.append(key, value.toString());\n    }\n  }\n  return urlSearchParams.toString();\n}\nasync function prepareFormData(formData, request) {\n  // validate content type (multipart/form-data)\n  const contentType = request.headers.get(\"Content-Type\");\n  if (contentType && !contentType.startsWith(\"multipart/form-data\")) {\n    // content type is specified and is not multipart/form-data. Exit.\n    return;\n  }\n  request.headers.set(\"Content-Type\", contentType !== null && contentType !== void 0 ? contentType : \"multipart/form-data\");\n  // set body to MultipartRequestBody using content from FormDataMap\n  const parts = [];\n  for (const [fieldName, values] of Object.entries(formData)) {\n    for (const value of Array.isArray(values) ? values : [values]) {\n      if (typeof value === \"string\") {\n        parts.push({\n          headers: createHttpHeaders({\n            \"Content-Disposition\": `form-data; name=\"${fieldName}\"`\n          }),\n          body: stringToUint8Array(value, \"utf-8\")\n        });\n      } else if (value === undefined || value === null || typeof value !== \"object\") {\n        throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);\n      } else {\n        // using || instead of ?? here since if value.name is empty we should create a file name\n        const fileName = value.name || \"blob\";\n        const headers = createHttpHeaders();\n        headers.set(\"Content-Disposition\", `form-data; name=\"${fieldName}\"; filename=\"${fileName}\"`);\n        // again, || is used since an empty value.type means the content type is unset\n        headers.set(\"Content-Type\", value.type || \"application/octet-stream\");\n        parts.push({\n          headers,\n          body: value\n        });\n      }\n    }\n  }\n  request.multipartBody = {\n    parts\n  };\n}","map":{"version":3,"names":["isNodeLike","stringToUint8Array","createHttpHeaders","formDataPolicyName","formDataToFormDataMap","formData","formDataMap","key","value","entries","_a","push","formDataPolicy","name","sendRequest","request","next","FormData","body","undefined","contentType","headers","get","indexOf","wwwFormUrlEncode","prepareFormData","urlSearchParams","URLSearchParams","Object","Array","isArray","subValue","append","toString","startsWith","set","parts","fieldName","values","Error","fileName","type","multipartBody"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\@azure\\core-rest-pipeline\\src\\policies\\formDataPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { isNodeLike, stringToUint8Array } from \"@azure/core-util\";\nimport { createHttpHeaders } from \"../httpHeaders.js\";\nimport type {\n  BodyPart,\n  FormDataMap,\n  FormDataValue,\n  PipelineRequest,\n  PipelineResponse,\n  SendRequest,\n} from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\n\n/**\n * The programmatic identifier of the formDataPolicy.\n */\nexport const formDataPolicyName = \"formDataPolicy\";\n\nfunction formDataToFormDataMap(formData: FormData): FormDataMap {\n  const formDataMap: FormDataMap = {};\n  for (const [key, value] of formData.entries()) {\n    formDataMap[key] ??= [];\n    (formDataMap[key] as FormDataValue[]).push(value);\n  }\n  return formDataMap;\n}\n\n/**\n * A policy that encodes FormData on the request into the body.\n */\nexport function formDataPolicy(): PipelinePolicy {\n  return {\n    name: formDataPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (isNodeLike && typeof FormData !== \"undefined\" && request.body instanceof FormData) {\n        request.formData = formDataToFormDataMap(request.body);\n        request.body = undefined;\n      }\n\n      if (request.formData) {\n        const contentType = request.headers.get(\"Content-Type\");\n        if (contentType && contentType.indexOf(\"application/x-www-form-urlencoded\") !== -1) {\n          request.body = wwwFormUrlEncode(request.formData);\n        } else {\n          await prepareFormData(request.formData, request);\n        }\n\n        request.formData = undefined;\n      }\n      return next(request);\n    },\n  };\n}\n\nfunction wwwFormUrlEncode(formData: FormDataMap): string {\n  const urlSearchParams = new URLSearchParams();\n  for (const [key, value] of Object.entries(formData)) {\n    if (Array.isArray(value)) {\n      for (const subValue of value) {\n        urlSearchParams.append(key, subValue.toString());\n      }\n    } else {\n      urlSearchParams.append(key, value.toString());\n    }\n  }\n  return urlSearchParams.toString();\n}\n\nasync function prepareFormData(formData: FormDataMap, request: PipelineRequest): Promise<void> {\n  // validate content type (multipart/form-data)\n  const contentType = request.headers.get(\"Content-Type\");\n  if (contentType && !contentType.startsWith(\"multipart/form-data\")) {\n    // content type is specified and is not multipart/form-data. Exit.\n    return;\n  }\n\n  request.headers.set(\"Content-Type\", contentType ?? \"multipart/form-data\");\n\n  // set body to MultipartRequestBody using content from FormDataMap\n  const parts: BodyPart[] = [];\n\n  for (const [fieldName, values] of Object.entries(formData)) {\n    for (const value of Array.isArray(values) ? values : [values]) {\n      if (typeof value === \"string\") {\n        parts.push({\n          headers: createHttpHeaders({\n            \"Content-Disposition\": `form-data; name=\"${fieldName}\"`,\n          }),\n          body: stringToUint8Array(value, \"utf-8\"),\n        });\n      } else if (value === undefined || value === null || typeof value !== \"object\") {\n        throw new Error(\n          `Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`,\n        );\n      } else {\n        // using || instead of ?? here since if value.name is empty we should create a file name\n        const fileName = (value as File).name || \"blob\";\n        const headers = createHttpHeaders();\n        headers.set(\n          \"Content-Disposition\",\n          `form-data; name=\"${fieldName}\"; filename=\"${fileName}\"`,\n        );\n\n        // again, || is used since an empty value.type means the content type is unset\n        headers.set(\"Content-Type\", value.type || \"application/octet-stream\");\n\n        parts.push({\n          headers,\n          body: value,\n        });\n      }\n    }\n  }\n  request.multipartBody = { parts };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}