{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.instanceLookup = instanceLookup;\nexports.parseBrowserResponse = parseBrowserResponse;\nvar _dns = _interopRequireDefault(require(\"dns\"));\nvar _abortError = _interopRequireDefault(require(\"./errors/abort-error\"));\nvar _sender = require(\"./sender\");\nvar _withTimeout = require(\"./utils/with-timeout\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nconst SQL_SERVER_BROWSER_PORT = 1434;\nconst TIMEOUT = 2 * 1000;\nconst RETRIES = 3;\n// There are three bytes at the start of the response, whose purpose is unknown.\nconst MYSTERY_HEADER_LENGTH = 3;\n// Most of the functionality has been determined from from jTDS's MSSqlServerInfo class.\nasync function instanceLookup(options) {\n  var _options$lookup, _options$port;\n  const server = options.server;\n  if (typeof server !== 'string') {\n    throw new TypeError('Invalid arguments: \"server\" must be a string');\n  }\n  const instanceName = options.instanceName;\n  if (typeof instanceName !== 'string') {\n    throw new TypeError('Invalid arguments: \"instanceName\" must be a string');\n  }\n  const timeout = options.timeout === undefined ? TIMEOUT : options.timeout;\n  if (typeof timeout !== 'number') {\n    throw new TypeError('Invalid arguments: \"timeout\" must be a number');\n  }\n  const retries = options.retries === undefined ? RETRIES : options.retries;\n  if (typeof retries !== 'number') {\n    throw new TypeError('Invalid arguments: \"retries\" must be a number');\n  }\n  if (options.lookup !== undefined && typeof options.lookup !== 'function') {\n    throw new TypeError('Invalid arguments: \"lookup\" must be a function');\n  }\n  const lookup = (_options$lookup = options.lookup) !== null && _options$lookup !== void 0 ? _options$lookup : _dns.default.lookup;\n  if (options.port !== undefined && typeof options.port !== 'number') {\n    throw new TypeError('Invalid arguments: \"port\" must be a number');\n  }\n  const port = (_options$port = options.port) !== null && _options$port !== void 0 ? _options$port : SQL_SERVER_BROWSER_PORT;\n  const signal = options.signal;\n  if (signal.aborted) {\n    throw new _abortError.default();\n  }\n  let response;\n  for (let i = 0; i <= retries; i++) {\n    try {\n      response = await (0, _withTimeout.withTimeout)(timeout, async signal => {\n        const request = Buffer.from([0x02]);\n        return await (0, _sender.sendMessage)(options.server, port, lookup, signal, request);\n      }, signal);\n    } catch (err) {\n      // If the current attempt timed out, continue with the next\n      if (!signal.aborted && err instanceof Error && err.name === 'TimeoutError') {\n        continue;\n      }\n      throw err;\n    }\n  }\n  if (!response) {\n    throw new Error('Failed to get response from SQL Server Browser on ' + server);\n  }\n  const message = response.toString('ascii', MYSTERY_HEADER_LENGTH);\n  const foundPort = parseBrowserResponse(message, instanceName);\n  if (!foundPort) {\n    throw new Error('Port for ' + instanceName + ' not found in ' + options.server);\n  }\n  return foundPort;\n}\nfunction parseBrowserResponse(response, instanceName) {\n  let getPort;\n  const instances = response.split(';;');\n  for (let i = 0, len = instances.length; i < len; i++) {\n    const instance = instances[i];\n    const parts = instance.split(';');\n    for (let p = 0, partsLen = parts.length; p < partsLen; p += 2) {\n      const name = parts[p];\n      const value = parts[p + 1];\n      if (name === 'tcp' && getPort) {\n        const port = parseInt(value, 10);\n        return port;\n      }\n      if (name === 'InstanceName') {\n        if (value.toUpperCase() === instanceName.toUpperCase()) {\n          getPort = true;\n        } else {\n          getPort = false;\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["_dns","_interopRequireDefault","require","_abortError","_sender","_withTimeout","obj","__esModule","default","SQL_SERVER_BROWSER_PORT","TIMEOUT","RETRIES","MYSTERY_HEADER_LENGTH","instanceLookup","options","_options$lookup","_options$port","server","TypeError","instanceName","timeout","undefined","retries","lookup","port","signal","aborted","response","i","withTimeout","request","Buffer","from","sendMessage","err","Error","name","message","toString","foundPort","parseBrowserResponse","getPort","instances","split","len","length","instance","parts","p","partsLen","value","parseInt","toUpperCase"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\tedious\\src\\instance-lookup.ts"],"sourcesContent":["import dns from 'dns';\n\nimport AbortError from './errors/abort-error';\nimport { sendMessage } from './sender';\nimport { withTimeout } from './utils/with-timeout';\n\nconst SQL_SERVER_BROWSER_PORT = 1434;\nconst TIMEOUT = 2 * 1000;\nconst RETRIES = 3;\n// There are three bytes at the start of the response, whose purpose is unknown.\nconst MYSTERY_HEADER_LENGTH = 3;\n\ntype LookupFunction = (hostname: string, options: dns.LookupAllOptions, callback: (err: NodeJS.ErrnoException | null, addresses: dns.LookupAddress[]) => void) => void;\n\n// Most of the functionality has been determined from from jTDS's MSSqlServerInfo class.\nexport async function instanceLookup(options: { server: string, instanceName: string, timeout?: number, retries?: number, port?: number, lookup?: LookupFunction, signal: AbortSignal }) {\n  const server = options.server;\n  if (typeof server !== 'string') {\n    throw new TypeError('Invalid arguments: \"server\" must be a string');\n  }\n\n  const instanceName = options.instanceName;\n  if (typeof instanceName !== 'string') {\n    throw new TypeError('Invalid arguments: \"instanceName\" must be a string');\n  }\n\n  const timeout = options.timeout === undefined ? TIMEOUT : options.timeout;\n  if (typeof timeout !== 'number') {\n    throw new TypeError('Invalid arguments: \"timeout\" must be a number');\n  }\n\n  const retries = options.retries === undefined ? RETRIES : options.retries;\n  if (typeof retries !== 'number') {\n    throw new TypeError('Invalid arguments: \"retries\" must be a number');\n  }\n\n  if (options.lookup !== undefined && typeof options.lookup !== 'function') {\n    throw new TypeError('Invalid arguments: \"lookup\" must be a function');\n  }\n  const lookup = options.lookup ?? dns.lookup;\n\n  if (options.port !== undefined && typeof options.port !== 'number') {\n    throw new TypeError('Invalid arguments: \"port\" must be a number');\n  }\n  const port = options.port ?? SQL_SERVER_BROWSER_PORT;\n\n  const signal = options.signal;\n\n  if (signal.aborted) {\n    throw new AbortError();\n  }\n\n  let response;\n\n  for (let i = 0; i <= retries; i++) {\n    try {\n      response = await withTimeout(timeout, async (signal) => {\n        const request = Buffer.from([0x02]);\n        return await sendMessage(options.server, port, lookup, signal, request);\n      }, signal);\n    } catch (err) {\n      // If the current attempt timed out, continue with the next\n      if (!signal.aborted && err instanceof Error && err.name === 'TimeoutError') {\n        continue;\n      }\n\n      throw err;\n    }\n  }\n\n  if (!response) {\n    throw new Error('Failed to get response from SQL Server Browser on ' + server);\n  }\n\n  const message = response.toString('ascii', MYSTERY_HEADER_LENGTH);\n  const foundPort = parseBrowserResponse(message, instanceName);\n\n  if (!foundPort) {\n    throw new Error('Port for ' + instanceName + ' not found in ' + options.server);\n  }\n\n  return foundPort;\n}\n\nexport function parseBrowserResponse(response: string, instanceName: string) {\n  let getPort;\n\n  const instances = response.split(';;');\n  for (let i = 0, len = instances.length; i < len; i++) {\n    const instance = instances[i];\n    const parts = instance.split(';');\n\n    for (let p = 0, partsLen = parts.length; p < partsLen; p += 2) {\n      const name = parts[p];\n      const value = parts[p + 1];\n\n      if (name === 'tcp' && getPort) {\n        const port = parseInt(value, 10);\n        return port;\n      }\n\n      if (name === 'InstanceName') {\n        if (value.toUpperCase() === instanceName.toUpperCase()) {\n          getPort = true;\n        } else {\n          getPort = false;\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}